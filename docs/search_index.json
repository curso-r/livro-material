[["index.html", "Ciência de Dados em R Sobre", " Ciência de Dados em R Curso-R Última atualização: 18/02/2021 Sobre Este livro está em construção e em revisão aberta. Fique à vontade para corrigir qualquer tipo de erro que encontrar no nosso material. Todo o conteúdo deste livro é gratuito e aberto. Autoria: Athos Damiani Beatriz Milz Caio Lente Daniel Falbel Fernando Correa Julio Trecenti Nicole Luduvice William Amorim A Curso-R A Curso-R é o braço de Educação da R6 Consultoria, uma empresa de treinamentos e consultoria em Ciência de Dados e linguagem de programação R. Surgimos em 2015, com cursos de introdução ao R no Programa de Cursos de Verão do Instituto de Matemática e Estatística da Universidade de São Paulo (IME-USP). Conheça os nossos cursos: https://www.curso-r.com/cursos/ Conheça o nosso blog: https://www.curso-r.com/blog/ Conheça o restante do nosso material: https://www.curso-r.com/material/ Saiba mais sobre a Curso-R: https://www.curso-r.com/sobre/ O R e o RStudio O R é uma linguagem de programação open source para análise de dados que fornece uma grande variedade de ferramentas estatísticas e gráficas. O RStudio é o ambiente de desenvolvimento mais utilizado para programação em R. Ele possui diversas ferramentas que facilitam a utilização do R para se fazer análise de dados. Este livro Este livro tem como objetivo guiar o leitor por todas as etapas de uma análise de dados, utilizando o R como ferramenta. Nele, você encontrará ferramentas para importar, arrumar, manipular, visualizar e modelar bases de dados. E também ferramentas para comunicar e automatizar resultados. Figura 0.1: Arte por Allison Horst (@allison_horst). Veja nas Referências onde encontrá-la. Comunidade Seja bem-vinda(o) ao #rstats. Compartilhe seu desenvolvimento! Poste seus avaços nas redes sociais, compartilhe suas dúvidas em fóruns, procure e participe dos grupos e comunidades de programadores. Comunidade RLadies: https://benubah.github.io/r-community-explorer/rladies.html Fórum de dúvidas da Curso-R: https://discourse.curso-r.com/ Grupo de divulgação da Curso-R no Telegram: https://t.me/r6cursor Grupo R Brasil no Telegram: https://t.me/rbrasiloficial Figura 0.2: Arte por Allison Horst (@allison_horst). Veja nas Referências onde encontrá-la. Agradecimentos Haydee Svab - Revisão do conteúdo inicial sobre Markdown. "],["1-instalacao.html", "Capítulo 1 Instalação", " Capítulo 1 Instalação Nesta seção, abordaremos como instalar o R e o RStudio no Linux e no Windows. Também discutiremos sobre a instalação de pacotes no R. "],["1-1-instalação-do-r.html", "1.1 Instalação do R", " 1.1 Instalação do R A instalação padrão do R é feita a partir do CRAN, uma rede de servidores espalhada pelo mundo que armazena versões idênticas e atualizadas de códigos e documentações para o R. Sempre que for instalar algo do CRAN, utilize o servidor (mirror) mais próximo de você. 1.1.1 No Windows Para instalar o R no Windows, siga os seguintes passos: Acesse o CRAN: https://www.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Clique na opção base. Na nova página, clique em **Download R x.x.x for Windows*, sendo x.x.x o número da versão que será baixada. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. Feito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. Na etapa de escolher a pasta de destino da instalação, se você escolher um local que não esteja dentro da sua pasta de usuário, você precisará de acesso de administrador. Se escolher uma pasta dentro da sua paste de usuário, não precisará. 1.1.2 No Linux Como a instalação no Linux depende da distribuição utilizada e, em geral, pessoas que utilizam Linux são mais experientes, vamos informar apenas as coordenadas até as instruções/arquivos. Se você tiver alguma dificuldade durante o processo, por favor envie a sua dúvida para a nossa comunidade. Faremos o possível para ajudar. Acesse o CRAN: https://cran.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Clique em Download R for Linux. Clique no link referente à distribuição que você utiliza. Siga as instruções contidas na página para instalar o R. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. 1.1.3 No Mac Para instalar o R no Mac, siga os seguintes passos: Acesse o CRAN: https://www.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Na nova página, clique em **Download R for (Mac) OS X*. Clique na versão do R que você quer baixar (geralmente queremos baixar a mais recente). O objetivo aqui é baixar um arquivo do tipo “R-x.x.x.pkg”, sendo x.x.x o número da versão que vamos instalar. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. Feito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. "],["1-2-instalação-do-rstudio.html", "1.2 Instalação do RStudio", " 1.2 Instalação do RStudio Agora vamos instalar a versão open source do RStudio, a IDE que utilizaremos para escrever e executar códigos em R. Para instalar o RStudio no Windows, siga os seguintes passos: Acesse a página de downloads da RStudio: https://rstudio.com/products/rstudio/download/#download Se você tiver acesso administrador, baixe a versão referente ao seu sistema operacional que está na lista de All Installers. Se você não tiver acesso de administrador, baixe a versão referente ao seu sistema operacional que está na lista de Zip/Tarballs. Instalando se você for administrador Clique duas vezes no arquivo que você baixou da página do RStudio e siga as instruções de instalação. Instalação se você não for administrador Descompacte o arquivo baixado no passo anterior. Geralmente isso pode ser feito clicando no arquivo compactado com o botão direito do mouse e clicando na opção descompactar ou extrair. Após a descompactação ter sido finalizada, você terá uma pasta chamada: RStudio-x.x.x, em que x.x.x é o número da versão baixada. Abra essa pasta e entre na subpasta com nome bin. Procure pelo arquivo chamado rstudio e clique duas vezes. Isso abrirá o RStudio. Recomendamos fixar o programa na barra de tarefas para não precisar repetir essa etapa sempre que for abrir o programa. Observação: se você excluir a pasta que extraímos, o RStudio irá parar de funcionar. "],["2-rstudio.html", "Capítulo 2 RStudio", " Capítulo 2 RStudio O RStudio é sem dúvidas o mais completo ambiente de desenvolvimento para programação em R. Descubra aqui as funcionalidades do RStudio que nos permitem escrever códigos e analisar resultados de forma muito mais eficiente. "],["2-1-telas.html", "2.1 Telas", " 2.1 Telas Ao abrir o RStudio, você verá 4 quadrantes. Observe a figura abaixo. Esses quadrantes representam o editor, o console, o environment e o output. Eles vêm nesta ordem, mas você pode organizá-los da forma que preferir acessando a seção Pane Layout da opção Global options... no menu Tools. O editor e o console são os dois principais painéis do RStudio. Passaremos a maior parte do tempo neles. Editor/Scripts: é onde escrevemos nossos códigos. Repare que o RStudio colore algumas palavras e símbolos para facilitar a leitura do código. Console: é onde rodamos o código e recebemos as saídas. O R vive aqui! Os demais painéis são auxiliares. O objetivo deles é facilitar pequenas tarefas que fazem parte tanto da programação quanto da análise de dados, como olhar a documentação de funções, analisar os objetos criados em uma sessão do R, procurar e organizar os arquivos que compõem a nossa análise, armazenar e analisar os gráficos criados e muito mais. Environment: painel com todos os objetos criados na sessão. History: painel com um histórico dos comandos rodados. Files: mostra os arquivos no diretório de trabalho. É possível navegar entre diretórios. Plots: painel onde os gráficos serão apresentados. Packages: apresenta todos os pacotes instalados e carregados. Help: janela onde a documentação das funções serão apresentadas. Viewer: painel onde relatórios e dashboards serão apresentados. "],["2-2-atalhos.html", "2.2 Atalhos", " 2.2 Atalhos Conhecer os atalhos do teclado ajuda bastante quando estamos programando no RStudio. Veja os principais: CTRL+ENTER: avalia a linha selecionada no script. O atalho mais utilizado. ALT+-: cria no script um sinal de atribuição (&lt;-). Você o usará o tempo todo. CTRL+SHIFT+M: (%&gt;%) operador pipe. Guarde esse atalho, você o usará bastante. CTRL+1: altera cursor para o script. CTRL+2: altera cursor para o console. CTRL+ALT+I: cria um chunk no R Markdown. CTRL+SHIFT+K: compila um arquivo no R Markdown. ALT+SHIFT+K: janela com todos os atalhos disponíveis. No MacBook, os atalhos geralmente são os mesmos, substituindo o CTRL por command e o ALT por option. "],["2-3-projetos.html", "2.3 Projetos", " 2.3 Projetos Uma funcionalidade muito importante do RStudio é a possibilidade de criar projetos. Um projeto nada mais é do que uma pasta no seu computador. Nessa pasta, estarão todos os arquivos que você usurá ou criará na sua análise. A principal razão de utilizarmos projetos é organização. Com eles, fica muito mais fácil importar bases de dados para dentro do R, criar análises reprodutíveis e compartilhar o nosso trabalho. Você que está começando agora no R, já se habitue a criar um novo projeto para cada nova análise que for fazer. Para criar um projeto, clique em New Project... no Menu File. Na caixa de diálogo que aparecerá, clique em New Directory para criar o projeto em uma nova pasta ou Existing Directory para criar em uma pasta existente. Se você tiver o Git instalado, você também pode usar projetos para conectar com repositórios do Github e outras plataformas de desenvolvimento. Para isso, basta clicar em Version Control. Criando um projeto, o RStudio criará na pasta escolhida um arquivo nome-do-projeto.Rproj. Você pode usar esse arquivo para iniciar o RStudio já com o respectivo projeto aberto. Quando um projeto estiver aberto no RStudio, o seu nome aparecerá no canto superior direito da tela. Na aba Files, aparecerão todos os arquivos contidos no projeto. Você pode criar livremente novas pastas dentro da pasta do projeto. Por padrão, o R sempre começará a procurar arquivos na pasta raiz do projeto (é a pasta que contem o nome-do-projeto.Rproj). Uma maneira fácil de navegar entre projetos é utilizar o menu disponibilizado quando clicamos no nome do projeto. Veja a figura a seguir. Nesse menu, além de podermos criar novos projetos ou abrir projetos já existentes, também temos um acesso rápido a projetos abertos recentemente. Basta clicar em qualquer um deles para trocar de projeto, isto é, deixar de trabalhar em uma análise e começar a trabalhar em outra. A seguir, apresentamos algumas estruturas de organização de projetos no RStudio. Estrutura 1. Por extensão de arquivo. nome_do_projeto/ - .Rprofile # códigos para rodar assim que abrir o projeto - R/ # Código R, organizado com a-carrega.R, b-prepara bd.R, c-vis.R, d-modela, ... - RData/ # Dados em formato .RData - csv/ # Dados em .csv - png/ # gráficos em PNG - nome_do_projeto.Rproj Estrutura 2. Típico projeto de análise estatística. project/ - README.Rmd # Descrição do pacote - set-up.R # Pacotes etc - R/ # Código R, organizado com 0-load.R, 1-tidy.R, 2-vis.R, ... - data/ # Dados (estruturados ou não) - figures/ # gráficos (pode ficar dentro de output/) - output/ # Relatórios em .Rmd, .tex etc - project.Rproj Estrutura 3. Pacote do R. project/ - README.md # Descrição do pacote - DESCRIPTION # Metadados estruturados do pacote e dependências - NAMESPACE # importações e exportações do pacote - vignettes/ # Relatórios em .Rmd - R/ # Funções do R - data/ # Dados estruturados (tidy data) - data-raw/ # Dados não estruturados e arqs 0-load.R, 1-tidy.R, 2-vis.R, ... - project.Rproj "],["2-4-git-e-versionamento.html", "2.4 Git e versionamento", " 2.4 Git e versionamento "],["2-5-cheatsheets.html", "2.5 Cheatsheets", " 2.5 Cheatsheets O RStudio tem à disposição algumas folhas de cola, as cheatsheets. Elas trazem um resumão de como utilizar diversos pacotes e até o próprio RStudio. Para acessá-las, basta clicar no menu Help e então em Cheatsheets. Outra forma de acessá-las é através do site da RStudio, onde existem muitas opções de cheatsheets, incluindo algumas traduzidas para o Português. "],["2-6-addins.html", "2.6 Addins", " 2.6 Addins "],["2-7-snippets.html", "2.7 Snippets", " 2.7 Snippets "],["3-r-base.html", "Capítulo 3 R Básico", " Capítulo 3 R Básico Introduziremos aqui os principais conceitos de programação em R. Indicamos a leitura deste capítulo a quem nunca teve contato com uma linguagem de programação ou a quem gostaria de entender um pouco melhor a estrutura de objetos, funções e classes do R. Os tópicos discutidos aqui são especialmente importantes para entendermos o que é um data frame, a nossa base de dados dentro do R, e quais operações estão sendo realizadas por trás das cortinas quando estivermos filtrando suas linhas ou modificando suas colunas. Também são importantes para começarmos a criar as nossas próprias funções, o que deixa nossos códigos muito mais organizados, eficientes e compartilháveis. "],["3-1-pedindo-ajuda.html", "3.1 Pedindo Ajuda", " 3.1 Pedindo Ajuda A linguagem R é bem intuitiva. É possível fazer bastante coisa à base da tentativa e erro. Além disso, grande parte do conhecimento é escalável, isto é, aprender a utilizar uma função é meio caminho andado para aprender todas as outras funções que operam de forma semelhante1. No entanto, a intuição não infalível, e recorrentemente vamos precisar de ajuda para rodar alguma função ou descobrir como fazer alguma tarefa no R. Felizmente, a comunidade R é bem ativa e existem vários lugares para buscar respostas. Nesta seção, vamos apresentar as principais maneiras algumas dessas maneiras. Figura 3.1: Arte por Allison Horst (@allison_horst). Veja nas Referências onde encontrá-la. No R, há quatro principais entidades para se pedir ajuda: Help/documentação do R Google Stack Overflow Coleguinha A busca por ajuda é feita preferencialmente, mas não necessariamente, na ordem acima. 3.1.1 Documentação do R A documentação do R serve para você aprender a usar uma determinada função. Se você não sabe o que é uma função, não se preocupe. Discutiremos esse tópico nas Seções 3.3 e 3.11. Você pode acessar a documentação de uma função2 das seguintes maneiras: ?mean help(mean) Algumas dicas: Leia a seção Usage para ter noção de como usar a função. Os parâmetros da função estão descritos em Arguments. Os exemplos no final são particularmente úteis. Caso essa função não atenda às suas necessidades, a seção See Also sugere funções relacionadas. Alguns pacotes possuem tutorias de uso mais completos. Esses textos são chamados de vignettes e podem ser acessados com a função vignette(package = 'nomeDoPacote'). Por exemplo, vignette(package = 'dplyr'). 3.1.2 Google Há uma comunidade gigantesca de usuários de R gerando diariamente uma infinidade de conteúdos e discussões. Não raramente, você irá encontrar discussões sobre o seu problema simplesmente o descrevendo no Google. Pesquisas em inglês aumentam consideravelmente a chance de encontrar uma resposta. Quando você recebe um erro na tentativa de rodar algum código no R e não sabe o que está errado, uma boa estratégia é pesquisar a mensagem de erro no Google. Essa deve ser sua primeira tentativa para resolver o problema. Repare na imagem abaixo o ‘r’ adicionado na busca. Isso ajuda bastante a encontrar uma solução. log(&quot;5&quot;) ## Error in log(&quot;5&quot;): non-numeric argument to mathematical function 3.1.3 Stack Overflow O Stack Overflow e o Stack Overflow em Português são sites de Pergunta e Resposta amplamente utilizados por todas as linguagens de programação, e o R é uma delas. Nos EUA, chegam até a usar a reputação dos usuários dentro da plataforma como diferencial no currículo! Provavelmente o Google lhe indicará uma página deles quando você estiver procurando ajuda. E quando todas as fontes possíveis de ajuda falharem, o Stack Overflow lhe dará o espaço para criar sua própria pergunta. Um ponto importante: como fazer uma boa pergunta no Stack Overflow? No site, existe um tutorial com uma lista de boas práticas, que se encontra aqui. Resumindo, as principais dicas são ser conciso; ser específico; ter mente aberta; e ser gentil. Porém, no caso do R, há outro requisito que vai aumentar muito sua chance de ter uma boa resposta: exemplinho minimal e reprodutível. Ser minimal: usar bancos de dados menores e utilizar pedaços de códigos apenas suficientes para apresentar o seu problema. Não precisa de banco de dados de um milhão de linhas e nem colocar o seu código inteiro para descrever a sua dúvida. Ser reprodutível: o seu código deve rodar fora da sua máquina. Se você não fornecer uma versão do seu problema que rode (ou que imite seu erro), as pessoas vão logo desistir de te ajudar. Por isso, nunca coloque bancos de dados que só você tem acesso. Use bancos de dados que já vem no R ou disponibilize um exemplo (possivelmente anonimizado) em .csv na web para baixar. E se precisar utilizar funções de algum pacote, especifique os pacotes que você usou. Essa ideia é um dos princípios por trás do tidyverse.↩︎ Bases de dados presentes em pacotes também têm documentação, e geralmente é possível encontrar o significado de cada variável nela. Por exemplo, help(mtcars).↩︎ "],["3-2-r-como-calculadora.html", "3.2 R como calculadora", " 3.2 R como calculadora O papel do Console no R é executar os nossos comandos. Ele avalia o código que passamos para ele e devolve a saída correspondente — se tudo der certo — ou uma mensagem de erro — se o seu código tiver algum problema. Vamos começar com o exemplo mais simples possível: 1 + 1 ## [1] 2 Nesse caso, o nosso comando foi o código 1 + 1 e a saída foi o valor 2. Quando compilamos? Quem vem de linguagens como o C ou Java espera que seja necessário compilar o código em texto para o código das máquinas (geralmente um código binário). No R, isso não é necessário. O R é uma linguagem de programação dinâmica que interpreta o seu código enquanto você o executa. Tente agora jogar no console a expressão: 2 * 2 - (4 + 4) / 2. Pronto! Você já é capaz de pedir ao R para fazer qualquer uma das quatro operações aritméticas básicas. A seguir, apresentamos uma lista resumindo como fazer as principais operações no R. # adição 1 + 1 ## [1] 2 # subtração 4 - 2 ## [1] 2 # multiplicação 2 * 3 ## [1] 6 # divisão 5 / 3 ## [1] 1.666667 # potência 4 ^ 2 ## [1] 16 # resto da divisão de 5 por 3 5 %% 3 ## [1] 2 # parte inteira da divisão de 5 por 3 5 %/% 3 ## [1] 1 Repare que as operações e suas precedências são mantidas como na matemática, ou seja, divisão e multiplicação são calculadas antes da adição e subtração. E os parênteses nunca são demais! Uma outra forma de executar uma expressão é escrever o código em um script, deixar o cursor em cima da linha e usar o atalho Ctrl + Enter. Assim, o comando é enviado para o Console, onde é diretamente executado. Essa operação é chamada de avaliar, executar ou rodar o código. Se você digitar um comando incompleto, como 5 +, e apertar Enter, o R mostrará um +, o que não tem nada a ver com a adição da matemática. Isso significa que o R está esperando que você enviar mais algum código para completar o seu comando. Termine o seu comando ou aperte Esc para recomeçar. &gt; 5 - + + 5 [1] 0 Se você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro. NÃO ENTRE EM PÂNICO! Ele só está avisando que não conseguiu interpretar o comando. Você pode digitar outro comando normalmente em seguida. &gt; 5 % 2 Error: unexpected input in &quot;5 % 2&quot; &gt; 5 ^ 2 [1] 25 Exercícios 1. Qual a diferença entre o R e o RStudio? 2. Podemos usar o RStudio sem o R? E o R sem o RStudio? 3. Precisamos compilar nossos códigos de R? 4. Calcule o número de ouro no R. Dica: o número de ouro é dado pela expressão \\(\\frac{1 + \\sqrt{5}}{2}\\). 5. Por que é preferível escrevermos sempre o nosso código no script e não no Console? "],["3-3-objetosFuncoes.html", "3.3 Objetos e funções", " 3.3 Objetos e funções O R te permite salvar valores dentro de um objeto. Um objeto é simplesmente um nome que guarda um valor. Para criar um objeto, utilizamos o operador &lt;-. No exemplo abaixo, salvamos o valor 1 em a. Sempre que avaliarmos o objeto a, o R vai devolver o valor 1. # Salvando `1` em `a` a &lt;- 1 # Avaliando o objeto `a` a ## [1] 1 Existem algumas regras para dar nomes aos objetos. A mais importante é: o nome deve começar com uma letra3. O nome pode conter números, mas não pode começar com números. Você pode usar pontos . e underlines _ para separar palavras. # Permitido x &lt;- 1 x1 &lt;- 2 objeto &lt;- 3 meu_objeto &lt;- 4 meu.objeto &lt;- 5 # Não permitido 1x &lt;- 1 _objeto &lt;- 2 meu-objeto &lt;- 3 Atenção! O R diferencia letras maiúsculas e minúsculas, isto é, b é considerado um objeto diferente de B. Rode o exemplo abaixo e observe que dois objetos diferentes são criados no Environment. b &lt;- 2 B &lt;- 3 b ## [1] 2 B ## [1] 3 O objeto mais importante para o cientista de dados é, claro, a base de dados. No R, uma base de dados é representa por objetos chamados de data frames. Na próxima seção, vamos entender o que são esses objetos. Enquanto objetos são nomes que guardam valores, funções no R são nomes que guardam um código de R. A ideia é muito simples: sempre que você rodar uma função, o código que ela guarda será executado e um resultado nos será devolvido. A sintaxe para usar uma função é a seguinte: nome_da_funcao(arg1, arg2, argn) Entre parênteses, após o nome da função, temos o que chamamos de argumentos. Uma função pode ter qualquer número de argumentos e eles são sempre separados por vírgula. Basicamente, uma função recebe seus argumentos, executa uma ação sobre ou a partir deles e devolve um resultado. Por exemplo sum(1, 2) ## [1] 3 A função sum() recebeu os argumentos 1 e 2, somou os dois valores e devolveu o resultado dessa operação: o valor 3. Falaremos mais sobre funções na Seção 3.11. Exercícios 1. Qual a diferença entre os códigos abaixo? # Código 1 33 / 11 # Código 2 divisao &lt;- 33 / 11 2. Multiplique a sua idade por meses e salve o resultado em um objeto chamado idade_em_meses. Em seguida, multiplique esse objeto por 30 e salve o resultado em um objeto chamado idade_em_dias. 3. Por que o nome meu-objeto não pode ser utilizado para criar um objeto? O que significa a mensagem de erro resultante? meu-objeto &lt;- 1 ## Error in meu - objeto &lt;- 1: object &#39;meu&#39; not found Ou com um ponto.↩︎ "],["3-4-data-frames.html", "3.4 Data frames", " 3.4 Data frames Os data frames são de extrema importância no R, pois são os objetos que guardam os nossos dados. Eles são equivalentes a uma tabela do SQL ou uma planilha do Excel. A principal característica de um data frame é possuir linhas e colunas4. Veja o exemplo abaixo: mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 O mtcars é um data frame nativo do R que contém informações sobre diversos modelos de carros. Ele possui 32 linhas e 11 colunas5. Se você quiser saber mais sobre o mtcars, veja a documentação dele rodando ?mtcars no Console. Nos próximos capítulos, os data frames serão o nosso principal objeto de estudo. Aprenderemos a selecionar, criar e modificar colunas, filtrar e ordenar linhas, juntar dois data frames e, a partir deles, construiremos gráficos e ajustaremos modelos. Mas, da mesma forma que é muito mais fácil aprendermos a fritar um ovo após entendermos o que é o fogo, uma frigideira e um ovo, vamos estudar nas próximas seções quais são as estruturas que formam os data frames e como manipulá-las. Você pode construir um data frame vazio, com 0 linha e 0 coluna. No entanto, a estrutura de linhas e colunas estará presente.↩︎ A primeira “coluna” representa apenas o nome das linhas (modelo do carro), não é uma coluna da base. Repare que ela não possui um nome, como as outras. Essa estrutura de nome de linha é própria de data frames no R. Se exportássemos essa base para o Excel, por exemplo, essa coluna não apareceria.↩︎ "],["3-5-classes.html", "3.5 Classes", " 3.5 Classes A classe de um objeto é muito importante dentro do R. É a partir dela que as funções e operadores conseguem saber exatamente o que fazer com um objeto. Por exemplo, podemos somar dois números, mas não conseguimos somar duas letras (texto): 1 + 1 ## [1] 2 &quot;a&quot; + &quot;b&quot; ## Error in &quot;a&quot; + &quot;b&quot;: non-numeric argument to binary operator O operador + verifica que \"a\" e \"b\" não são números (ou que a classe deles não é numérica) e devolve uma mensagem de erro informando isso. Observe que para criar texto no R, colocamos os caracteres entre aspas. As aspas servem para diferenciar nomes (objetos, funções, pacotes) de textos (letras e palavras). Os textos são muito comuns em variáveis categóricas e são popularmente chamados de strings no contexto de programação. a &lt;- 10 # O objeto `a`, sem aspas a ## [1] 10 # A letra (texto) `a`, com aspas &quot;a&quot; ## [1] &quot;a&quot; Para saber a classe de um objeto, basta rodarmos class(nome-do-objeto). x &lt;- 1 class(x) ## [1] &quot;numeric&quot; y &lt;- &quot;a&quot; class(y) ## [1] &quot;character&quot; class(mtcars) ## [1] &quot;data.frame&quot; As classes mais básicas dentro do R são: numeric character logical Geralmente serão utilizados como sinônimos: texto, string, character, caracteres número, valor real, numeric, double lógico, logical, booleano, valor TRUE/FALSE Veja alguns exemplos: # numeric 1 0.10 0.95 pi # characters &quot;a&quot; &quot;1&quot; &quot;positivo&quot; # logical TRUE FALSE Um objeto de qualquer uma dessas classes é chamado de objeto atômico. Esse nome se deve ao fato de essas classes não se misturarem, isto é, para um objeto ter a classe numeric, por exemplo, todos os seus valores precisam ser numéricos. Mas como atribuir mais de um valor a um mesmo objeto? Para isso, precisamos criar vetores. 3.5.1 Exercícios 1. Guarde em um objeto chamado nome uma string contendo o seu nome completo. 2. Guarde em um objeto chamado cidade o nome da cidade onde você mora. Em seguida, guarde em um objeto chamado estado o nome do estado onde você mora. Usando esses objetos, resolva os itens abaixo: a. Utilize a função nchar() para contar o número de caracteres em cada cada string. b. Interprete o resultado do seguinte código: paste(cidade, estado) c. Interprete o resultado do seguinte código: paste(cidade, estado, sep = &quot; - &quot;) d. Desafio. Como você reproduziria o mesmo resultado do item (b) sem utilizar o argumento sep? e. Qual a diferença entre as funções paste() e paste0()? "],["3-6-vetores.html", "3.6 Vetores", " 3.6 Vetores Vetores são estruturas muito importantes dentro R. Em especial, pensando em análise de dados, precisamos estudá-los pois cada coluna de um data frame será representada como um vetor. Vetores no R são apenas conjuntos indexados de valores. Para criá-los, basta colocar os valores separados por vírgulas dentro de um c(). vetor1 &lt;- c(1, 5, 3, -10) vetor2 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) vetor1 ## [1] 1 5 3 -10 vetor2 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Os objetos vetor1 e vetor2 são vetores. Uma maneira fácil de criar um vetor com uma sequência de números é utilizar o operador :. # Vetor de 1 a 10 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # Vetor de 10 a 1 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 # Vetor de -3 a 3 -3:3 ## [1] -3 -2 -1 0 1 2 3 Quando dizemos que vetores são conjuntos indexados, isso quer dizer que cada valor dentro de um vetor tem uma posição. Essa posição é dada pela ordem em que os elementos foram colocados no momento em que o vetor foi criado. Isso nos permite acessar individualmente cada valor de um vetor. Para isso, colocamos o índice do valor que queremos acessar dentro de colchetes []. vetor &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) vetor[1] ## [1] &quot;a&quot; vetor[2] ## [1] &quot;b&quot; vetor[3] ## [1] &quot;c&quot; vetor[4] ## [1] &quot;d&quot; Você também pode colocar um conjunto de índices dentro dos colchetes, para pegar os valores contidos nessas posições: vetor[c(2, 3)] ## [1] &quot;b&quot; &quot;c&quot; vetor[c(1, 2, 4)] ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; Essa operação é conhecida como subsetting, pois estamos pegando subconjuntos de valores de um vetor. Se você tentar acessar uma posição do vetor que não existe, ele retornará NA, indicando que esse valor não existe. Discutiremos o que são NA’s na Seção 3.8. vetor[5] ## [1] NA Um vetor só pode guardar um tipo de objeto e ele terá sempre a mesma classe dos objetos que guarda. Para saber a classe de um vetor, rodamos class(nome-do-vetor). vetor1 &lt;- c(1, 5, 3, -10) vetor2 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) class(vetor1) ## [1] &quot;numeric&quot; class(vetor2) ## [1] &quot;character&quot; Se tentarmos misturar duas classes, o R vai apresentar o comportamento conhecido como coerção. vetor &lt;- c(1, 2, &quot;a&quot;) vetor ## [1] &quot;1&quot; &quot;2&quot; &quot;a&quot; class(vetor) ## [1] &quot;character&quot; Veja que todos os elementos do vetor se transformaram em texto. Agora temos um vetor com o texto \"1\", o texto \"2\" e o texto \"a\". Como um vetor só pode ter uma classe de objeto dentro dele, classes mais fracas serão sempre reprimidas pelas classes mais fortes. Como regra de bolso: caracteres serão sempre a classe mais forte. Então, sempre que você misturar números e texto em um vetor, os números virarão texto. Falaremos bastante de coerção nas próximas seções e capítulos, trazendo exemplos de quando ela ajuda e de quando ela atrapalha. De forma bastante intuitiva, você pode fazer operações com vetores. vetor &lt;- c(0, 5, 20, -3) vetor + 1 ## [1] 1 6 21 -2 Ao rodarmos vetor1 + 1, o R subtrai 1 de cada um dos elementos do vetor. O mesmo acontece com qualquer outra operação aritmética. vetor - 1 vetor / 2 vetor * 10 Você também pode fazer operações que envolvem mais de um vetor: vetor1 &lt;- c(1, 2, 3) vetor2 &lt;- c(10, 20, 30) vetor1 + vetor2 ## [1] 11 22 33 Neste caso, o R irá alinhar os dois vetores e somar elemento a elemento. Esse tipo de comportamento é chamado de vetorização. Isso pode ficar um pouco confuso quando os dois vetores não possuem o mesmo tamanho. Tente adivinhar qual será a saída do código a seguir: vetor1 &lt;- c(1, 2) vetor2 &lt;- c(10, 20, 30, 40) vetor1 + vetor2 ## [1] 11 22 31 42 Embora estejamos somando dois vetores de tamanho diferentes, o R não devolve um erro (o que parecia ser a resposta mais intuitiva). O R alinhou os dois vetores e, como eles não possuíam o mesmo tamanho, o primeiro foi repetido para ficar do mesmo tamanho do segundo. É como se o primeiro vetor fosse na verdade c(1, 2, 1, 2). Esse comportamento é chamado de reciclagem. Embora contra-intuitiva, a reciclagem é muito útil no R graças a um caso particular muito importante. Quando somamos vetor + 1 no nosso primeiro exemplo, o que o R está fazendo por trás é transformando o 1 em c(1, 1, 1, 1) e realizando a soma vetorizada c(0, 5, 20, -3) + c(1, 1, 1, 1). Isso porque o número 1 nada mais é do que um vetor de tamanho 1, isto é, 1 é igual a c(1). Usaremos esse comportamento no R o tempo todo e é muito importante a reciclagem para termos certeza de que o R está fazendo exatamente aquilo que gostaríamos que ele fizesse. Um outro caso interessante de reciclagem é quando o comprimento dos vetores não são múltiplos um do outro. vetor1 &lt;- c(1, 2, 3) vetor2 &lt;- c(10, 20, 30, 40, 50) vetor1 + vetor2 ## Warning in vetor1 + vetor2: longer object length is not a multiple of shorter ## object length ## [1] 11 22 33 41 52 Neste caso, duas coisas aconteceram: O R realizou a conta, repetindo cada valor do primeiro vetor até que os dois tenham o mesmo tamanho. No fundo, a operação realizada foi c(1, 2, 3, 1, 2) + c(10, 20, 30, 40, 50). Como essa operação é ainda menos intuitiva e raramente desejada, o R devolveu um aviso dizendo que o comprimento do primeiro vetor maior não é um múltiplo do comprimento do vetor menor. Exercícios 1. Guarde em um objeto a sequência de números de 0 a 5 e resolva os itens abaixos. a. Use subsetting para fazer o R devolver o primeiro número dessa sequência. Em seguida, faça o R devolver o último número da sequência. b. Multiplique todos os valores do vetor por -1. Guarde o resultado em um novo objeto chamado vetor_negativo. 2. Crie um vetor com o nome de tres frutas, guarde em um objeto chamado frutas e resolva os itens abaixo. a. Utilize a a função length() para verificar o tamanho do vetor. b. Inspecione a saída de paste(\"eu gosto de\", frutas) e responda se o tamanho do vetor mudou. 3. O que é reciclagem? Escreva um código em R que exemplifique esse comportamento. 4. O que é coerção? Escreva um código em R que exemplifique esse comportamento. 5. Por que a coerção pode ser um problema na hora de importarmos bases de dados para o R? 6. Use a função sum() para somar os valores de 1 a 100. 7. Considere o vetor booleano a seguir: dolar_subiu &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE) Este vetor tem informação de uma semana (7 dias, começando no domingo) indicando se o dólar subiu (TRUE) ou não subiu (FALSE) no respectivo dia. Interprete o resultado dos códigos abaixo: a. length(dolar_subiu) b. dolar_subiu[2] c. sum(dolar_subiu) d. mean(dolar_subiu) "],["3-7-testes-lógicos.html", "3.7 Testes lógicos", " 3.7 Testes lógicos Poder fazer qualquer tipo de operação lógica é um dos motivos pelos quais programar nos deixar mais eficientes. Dê bastante atenção a elas, pois usaremos comparações lógicas o tempo todo! Uma operação lógica nada mais é do que um teste que retorna verdadeiro ou falso. No R (e em outras linguagens de programação), esses valores dois valores recebem uma classe especial: logical. O verdadeiro no R vai ser representado pelo valor TRUE e o falso pelo valor FALSE. Esses nomes no R são reservados, isto é, você não pode chamar nenhum objeto de TRUE ou FALSE. TRUE &lt;- 1 ## Error in TRUE &lt;- 1 : invalid (do_set) left-hand side to assignment Checando a classe desses valores, vemos que são lógicos6. Eles são os únicos possíveis valores dessa classe. class(TRUE) ## [1] &quot;logical&quot; class(FALSE) ## [1] &quot;logical&quot; Agora que conhecemos o TRUE e FALSE, podemos explorar os teste lógicos. Começando pelo mais simples: vamos testar se um valor é igual ao outro. Para isso, usamos o operador ==. # Testes com resultado verdadeiro 1 == 1 ## [1] TRUE &quot;a&quot; == &quot;a&quot; ## [1] TRUE # Testes com resultado falso 1 == 2 ## [1] FALSE &quot;a&quot; == &quot;b&quot; ## [1] FALSE Também podemos testar se dois valores são diferentes. Para isso, usamos o operador !=. # Testes com resultado falso 1 != 1 ## [1] FALSE &quot;a&quot; != &quot;a&quot; ## [1] FALSE # Testes com resultado verdadeiro 1 != 2 ## [1] TRUE &quot;a&quot; != &quot;b&quot; ## [1] TRUE Para comparar se um valor é maior que outro, temos à disposição 4 operadores: # Maior 3 &gt; 3 ## [1] FALSE 3 &gt; 2 ## [1] TRUE # Maior ou igual 3 &gt; 4 ## [1] FALSE 3 &gt;= 3 ## [1] TRUE # Menor 3 &lt; 3 ## [1] FALSE 3 &lt; 4 ## [1] TRUE # Menor ou igual 3 &lt; 2 ## [1] FALSE 3 &lt;= 3 ## [1] TRUE Um outro operador muito útil é o %in%. Com ele, podemos verificar se um valor está dentro de um conjunto de valores (vetor). 3 %in% c(1, 2, 3) ## [1] TRUE &quot;a&quot; %in% c(&quot;b&quot;, &quot;c&quot;) ## [1] FALSE Nós começamos essa seção dizendo que usaremos testes lógicos o tempo todo. O motivo para isso é que eles fazem parte de uma operação muito comum na manipulação de base de dados: os filtros. No Excel, por exemplo, quando você filtra uma planilha, o que está sendo feito por trás é um teste lógico. Falamos anteriormente que cada coluna das nossas bases de dados será representada dentro do R como um vetor. O comportamento que explica a importância dos testes lógicos na hora de filtrar uma base está ilustrado abaixo: minha_coluna &lt;- c(1, 3, 0, 10, -1, 5, 20) minha_coluna &gt; 3 ## [1] FALSE FALSE FALSE TRUE FALSE TRUE TRUE minha_coluna[minha_coluna &gt; 3] ## [1] 10 5 20 Muitas coisas aconteceram aqui, vamos por partes. Primeiro, na operação minha_coluna &gt; 3 o R fez um excelente uso do comportamento de reciclagem. No fundo, o que ele fez foi transformar (reciclar) o valor 3 no vetor c(3, 3, 3, 3, 3, 3, 3) e testar se c(1, 3, 0, 10, -1, 5, 20) &gt; c(3, 3, 3, 3, 3, 3, 3). Como os operadores lógicos também são vetorizados (fazem operações elemento a elemento), os testes realizados foram 1 &gt; 3, 3 &gt; 3, 0 &gt; 3, 10 &gt; 3, -1 &gt; 3, 5 &gt; 3 e, finalmente, 20 &gt; 3. Cada um desses testes tem o seu próprio resultado. Por isso a saída de minha_coluna &gt; 3 é um vetor de verdadeiros e falsos, respectivos a cada um desses 7 testes. A segunda operação traz a grande novidade aqui: podemos usar os valores TRUE e FALSE para selecionar elementos de um vetor! A regra é muito simples: retornar as posições que receberem TRUE, não retornar as posições que receberem FALSE. Portanto, a segunda operação é equivalente a: minha_coluna[c(FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE)] ## [1] 10 5 20 O vetor lógico filtra o vetor minha_coluna, retornando apenas os valores maiores que 3, já que foi esse o teste lógico que fizemos. Essa é a mágica que acontece por trás de filtros no R. Na prática, não precisaremos usar colchetes, não lembraremos da reciclagem e nem veremos a cara dos TRUE e FALSE. Mas conhecer esse processo é muito importante, principalmente para encontrar problemas de código ou de base. A seguir, apresentamos uma tabela com os principais operadores lógicos: Para finalizar, listamos na tabela abaixo os principais operadores lógicos. Operador Descrição x &lt; y x menor que y? x &lt;= y x menor ou igual a y? x &gt; y x maior que y? x &gt;= y x maior ou igual a y? x == y x igual a y? x != y x diferente de y? !x Negativa de x x | y x ou y são verdadeiros? x &amp; y x e y são verdadeiros? x %in% y x percente a y? xor(x, y) x ou y são verdadeiros (apenas um deles)? Por fim, veja algumas diferenças entre comparações lógicas no SQL e no R: Igualdade: no SQL é só um sinal de igual: 2 = 1. No R são dois: 2 == 1. Diferença: no SQL, usamos &lt;&gt;. No R usamos !=. Negação: em vez de usar a palavra NOT igual ao SQL, usamos ! no R. Por exemplo, id not in ('1', '2', '3') fica !(id %in% c(1, 2, 3)). Exercícios 1 O código abaixo vai guardar no objeto segredo um número inteiro entre 0 e 10. Sem olhar qual número foi guardado no objeto, resolva os itens a seguir: segredo &lt;- round(runif(1, min = 0, max = 10)) a. Teste se o segredo é maior ou igual a 0. b. Teste se o segredo é menor ou igual a 10. c. Teste se o segredo é maior que 5. d. Teste se o segredo é par. e. Teste se segredo * 5 é maior que a sua idade. f. Desafio. Escreva um teste para descobrir o valor do segredo. 2. Escreva um código em R que devolva apenas os valores maiores ou iguais a 10 do vetor abaixo: vetor &lt;- c(4, 8, 15, 16, 23, 42) 3. Use o vetor numeross abaixo para responder as questoes seguintes. numeros &lt;- -4:2 a. Escreva um código que devolva apenas valores positivos do vetor numeros. b. Escreva um código que devolta apenas os valores pares do vetor numeros. c. Filtre o vetor para que retorne apenas aqueles valores que, quando elevados a 2, são menores do que 4. Também conhecidos como valores binários ou booleanos↩︎ "],["3-8-valoresEspeciais.html", "3.8 Valores especiais", " 3.8 Valores especiais Vimos anteriormente que se você tentar acessar uma posição que não existe dentro de um vetor, ele retorna um valor estranho. vetor &lt;- c(1, 2, 3) vetor[4] ## [1] NA Esse valor, o NA, é tratado de forma especial no R. Ele representa a ausência de informação, isto é, a informação existe, mas nós (e o R) não sabemos qual é. O NA para o R nada mais é do que o valor faltante ou omisso da Estatística. O famoso missing. Geralmente, quando temos uma base com valores faltando, como a idade para alguns indivíduos da nossa amostra, não significa que a idade deles não existe. Significa apenas que não temos essa informação. Esse conceito é muito importante para entender o resultado da expressão abaixo. 5 == NA ## [1] NA Em um primeiro momento, poderíamos esperar que o resultado fosse TRUE. Mas, sabendo o significado por trás do NA — um valor desconhecido —, a verdadeira pergunta que estamos fazendo é: 5 é igual a um valor que existe, mas que não sei qual é? É como se eu perguntasse se eu tenho 5 moedas na mão, mas lhe mostrasse a mão fechada. A resposta para isso é não sei ou, dentro do R, NA. Um outro exemplo: idade_ana &lt;- 30 idade_beto &lt;- NA idade_carla &lt;- NA idade_ana == idade_beto ## [1] NA idade_beto == idade_carla ## [1] NA Eu posso saber a idade da Ana, mas se eu não souber a idade do Beto, não sei se os dois tem a mesma idade. Por isso, NA. Da mesma forma, se não sei nem a idade do Beto nem da Carla, também não tenho como saber se os dois têm a mesma idade. Outra vez NA. Mas e quando queremos saber se um valor é NA ou não? Para fazer esse teste, temos que rodar is.na(valor-ou-objeto). is.na(NA) ## [1] TRUE is.na(idade_ana) ## [1] FALSE is.na(idade_beto) ## [1] TRUE Repare que essa função também é vetorizada. is.na(c(idade_ana, idade_beto, idade_carla)) ## [1] FALSE TRUE TRUE Assim como o NA, existem outros valores especiais muito comuns no R. O NaN (not a number) representa indefinições matemáticas. 0/0 ## [1] NaN log(-1) ## Warning in log(-1): NaNs produced ## [1] NaN O Inf (infinito) representa um número muito grande (que o computador não consegue representar) ou um limite matemático. # O computador não consegue representar um número tão grande. # O número é então &quot;&quot;&quot;arredondado&quot;&quot;&quot; para infinito. 10^310 ## [1] Inf # Limite matemático. 1 / 0 ## [1] Inf # O &quot;menos infinito&quot; também existe. -1 / 0 ## [1] -Inf O NULL (nulo) representa a ausência de um objeto. Ele não tem significado prático para a análise dados. Está mais em sintonia com comportamentos de lógica de programação. Muitas vezes vamos definir um objeto como nulo para dizer ao R que não queremos dar um valor para ele. Muito utilizado em funções. Da mesma forma que utilizados is.na() para testar se um objeto é NA, utilizamos is.nan(), is.infinite() ou is.null() para testar se um objeto é NaN, infinito ou nulo. nao_sou_um_numero &lt;- NaN objeto_infinito &lt;- Inf objeto_nulo &lt;- NULL is.nan(nao_sou_um_numero) ## [1] TRUE is.infinite(objeto_infinito) ## [1] TRUE is.null(objeto_nulo) ## [1] TRUE Exercícios 1. Quais as diferenças entre NaN, NULL, NA e Inf? Digite expressões que retornem cada um desses valores. 2. Escreva um código que conte o número de NAs do vetor b. b &lt;- c(1, 0, NA, NA, NA, NA, 7, NA, NA, NA, NA, NA, 2, NA, NA, 10, 1, 1, NA) "],["3-9-listas.html", "3.9 Listas", " 3.9 Listas Chegamos ao último tópico antes de voltarmos aos data frames: as listas. Listas são objetos muito importantes dentro do R. Primeiro porque todo data frame é uma lista. Segundo porque elas são bem parecidas com vetores, mas com uma diferença essencial: você pode misturar diferentes classes de objetos dentro dela. Para criar uma lista, rodamos list(valor1, valor2, valor3). list(1, &quot;a&quot;, TRUE) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE Veja que não houve coerção. Ainda temos um valor número, um texto e um valor lógico dentro da lista. O subsetting de listas é um pouco diferente do que o de vetores. Isso porque cada elemento de uma lista também é uma lista. Veja o que acontece se tentarmos usar [] para pegar um elemento de uma lista. lista &lt;- list(1, &quot;a&quot;, TRUE) lista[1] ## [[1]] ## [1] 1 class(lista[1]) ## [1] &quot;list&quot; O R nos retorna uma lista com apenas aquele elemento. Se quisermos o elemento de fato dentro de cada posição, precisamos usar dois colchetes: lista[[1]] ## [1] 1 class(lista[[1]]) ## [1] &quot;numeric&quot; Cada elemento de uma lista ser uma lista é importante pois isso nos permite colocar vetores de tamanhos diferentes em cada posição. Isso faz das listas uma estrutura bem flexível para guardar dados. lista &lt;- list(1:3, &quot;a&quot;, c(TRUE, TRUE, FALSE, FALSE)) lista ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE TRUE FALSE FALSE lista[1] ## [[1]] ## [1] 1 2 3 lista[2] ## [[1]] ## [1] &quot;a&quot; lista[3] ## [[1]] ## [1] TRUE TRUE FALSE FALSE É muito comum darmos nomes para cada posição de uma lista. dados_cliente &lt;- list(cliente = &quot;Ana Silva&quot;, idade = 25, estado_civil = NA) dados_cliente ## $cliente ## [1] &quot;Ana Silva&quot; ## ## $idade ## [1] 25 ## ## $estado_civil ## [1] NA Agora, dentro da lista, o valor Ana Silva, por exemplo, está sendo atribuído ao nome cliente. Esse nome só existirá dentro da lista. Um detalhe importante: os iguais utilizados nas atribuições dos nomes dentro da lista não podem ser substituídos por &lt;-. Quando as posições de uma lista tem nome, podemos acessar seus valores diretamente utilizando o operador $. dados_cliente$cliente ## [1] &quot;Ana Silva&quot; dados_cliente$idade ## [1] 25 dados_cliente$estado_civil ## [1] NA Repare que o R devolve o valor dentro de cada posição, e não uma lista. dados_cliente[1] ## $cliente ## [1] &quot;Ana Silva&quot; dados_cliente$cliente ## [1] &quot;Ana Silva&quot; class(dados_cliente[1]) ## [1] &quot;list&quot; class(dados_cliente$cliente) ## [1] &quot;character&quot; Isto implica que, nesse exemplo, dados_cliente$cliente é equivalente a dados_cliente[[1]]. Conforme ficamos mais e mais proficientes na linguagem R, as listas passam a ficar cada vez mais frequentes. Voltaremos a falar delas diversas vezes nos próximos capítulos, em especial no Capítulo 10. "],["3-10-mais-sobre-data-frames.html", "3.10 Mais sobre data frames", " 3.10 Mais sobre data frames Chegou a hora de usarmos tudo o que aprendemos na seção anterior para exploramos ao máximo o nosso objeto favorito: o data frame. Na seção anterior, nós dissemos que data frames são listas. Isso é importante pois todas as propriedades de uma lista valem para um data frame. A melhor forma de entender essa equivalência é ver um data frame representado como uma lista. as.list(mtcars) ## $mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 ## ## $cyl ## [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 ## ## $disp ## [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 275.8 ## [13] 275.8 275.8 472.0 460.0 440.0 78.7 75.7 71.1 120.1 318.0 304.0 350.0 ## [25] 400.0 79.0 120.3 95.1 351.0 145.0 301.0 121.0 ## ## $hp ## [1] 110 110 93 110 175 105 245 62 95 123 123 180 180 180 205 215 230 66 52 ## [20] 65 97 150 150 245 175 66 91 113 264 175 335 109 ## ## $drat ## [1] 3.90 3.90 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 3.92 3.07 3.07 3.07 2.93 ## [16] 3.00 3.23 4.08 4.93 4.22 3.70 2.76 3.15 3.73 3.08 4.08 4.43 3.77 4.22 3.62 ## [31] 3.54 4.11 ## ## $wt ## [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 ## [13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 ## [25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780 ## ## $qsec ## [1] 16.46 17.02 18.61 19.44 17.02 20.22 15.84 20.00 22.90 18.30 18.90 17.40 ## [13] 17.60 18.00 17.98 17.82 17.42 19.47 18.52 19.90 20.01 16.87 17.30 15.41 ## [25] 17.05 18.90 16.70 16.90 14.50 15.50 14.60 18.60 ## ## $vs ## [1] 0 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 1 0 1 0 0 0 1 ## ## $am ## [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 ## ## $gear ## [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4 ## ## $carb ## [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 O código acima nos permite ver o data frame mtcars representado como uma lista. Veja que cada coluna da base se transforma em um elemento da lista. E o nome de cada coluna vira o nome de cada posição. Isso é interessante, pois podemos usar nos data frames as mesmas operações que aprendemos para listas. Por exemplo, podemos usar o operador $ para acessar cada elemento da lista, isto é, cada coluna do data frame. mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 E assim como cada elemento de uma lista também é uma lista, cada elemento (coluna) de um data frame também é um *data frame. mtcars[1] ## mpg ## Mazda RX4 21.0 ## Mazda RX4 Wag 21.0 ## Datsun 710 22.8 ## Hornet 4 Drive 21.4 ## Hornet Sportabout 18.7 ## Valiant 18.1 ## Duster 360 14.3 ## Merc 240D 24.4 ## Merc 230 22.8 ## Merc 280 19.2 ## Merc 280C 17.8 ## Merc 450SE 16.4 ## Merc 450SL 17.3 ## Merc 450SLC 15.2 ## Cadillac Fleetwood 10.4 ## Lincoln Continental 10.4 ## Chrysler Imperial 14.7 ## Fiat 128 32.4 ## Honda Civic 30.4 ## Toyota Corolla 33.9 ## Toyota Corona 21.5 ## Dodge Challenger 15.5 ## AMC Javelin 15.2 ## Camaro Z28 13.3 ## Pontiac Firebird 19.2 ## Fiat X1-9 27.3 ## Porsche 914-2 26.0 ## Lotus Europa 30.4 ## Ford Pantera L 15.8 ## Ferrari Dino 19.7 ## Maserati Bora 15.0 ## Volvo 142E 21.4 class(mtcars[1]) ## [1] &quot;data.frame&quot; Mas se data frames são listas, por que existe a classe data frame? Na verdade, data frames são um tipo especial de listas, que têm as seguintes propriedades: Todos os seus elementos (colunas) precisam ter o mesmo comprimento (número de linhas). Todos os seus elementos (colunas) precisam ser nomeados. Data frames têm 2 dimensões. As propriedades (1) e (2) se devem ao formato das bases de dados. Elas são retangulares7 — observamos as mesmas variáveis (colunas) para todas as unidades amostrais (linhas)8 —, e precisam ter algum nome especificando as colunas. Da mesma forma que podemos ver um data frame como uma lista, também podemos fazer o inverso. dados_cliente &lt;- list( cliente = c(&quot;Ana Silva&quot;, &quot;Beto Pereira&quot;, &quot;Carla Souza&quot;), idade = c(25, 30, 23), estado_civil = c(NA, &quot;Solteiro&quot;, &quot;Casada&quot;) ) dados_cliente ## $cliente ## [1] &quot;Ana Silva&quot; &quot;Beto Pereira&quot; &quot;Carla Souza&quot; ## ## $idade ## [1] 25 30 23 ## ## $estado_civil ## [1] NA &quot;Solteiro&quot; &quot;Casada&quot; as.data.frame(dados_cliente) ## cliente idade estado_civil ## 1 Ana Silva 25 &lt;NA&gt; ## 2 Beto Pereira 30 Solteiro ## 3 Carla Souza 23 Casada Quando tivermos valores faltantes na nossa base (células vazias no Excel), eles serão representados por NA nos data frames. Observe que não conseguimos transformar uma lista em data frame se os elementos da lista não tiverem o mesmo comprimento. dados_cliente &lt;- list( cliente = c(&quot;Ana Silva&quot;, &quot;Beto Pereira&quot;, &quot;Carla Souza&quot;), idade = c(25, 30), estado_civil = c(NA, &quot;Solteiro&quot;, &quot;Casada&quot;) ) as.data.frame(dados_cliente) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2 Transformar uma lista não nomeada em data frame é possível, mas o R cria nomes nada agradáveis para as colunas. dados_cliente &lt;- list( c(&quot;Ana Silva&quot;, &quot;Beto Pereira&quot;, &quot;Carla Souza&quot;), c(25, 30, 23), c(NA, &quot;Solteiro&quot;, &quot;Casada&quot;) ) as.data.frame(dados_cliente) ## c..Ana.Silva....Beto.Pereira....Carla.Souza.. c.25..30..23. ## 1 Ana Silva 25 ## 2 Beto Pereira 30 ## 3 Carla Souza 23 ## c.NA...Solteiro....Casada.. ## 1 &lt;NA&gt; ## 2 Solteiro ## 3 Casada A propriedade (3) é atribuída aos data frames para que possamos aproveitar melhor dessa estrutura retangular dentro do R. Na prática, essas duas dimensões representam nada mais que as linhas e as colunas da base. Essa é a maior diferença entre uma lista e um data frame. class(mtcars) ## [1] &quot;data.frame&quot; dim(mtcars) ## [1] 32 11 O resultado do código dim(mtcars) nos dá as seguintes informações: O data frame mtcars tem duas dimensões (como todo data frame). A primeira dimensão tem comprimento 32 e a segunda dimensão tem comprimento 11. Em outras palavras: a base mtcars tem 32 linhas e 11 colunas. Veja a seguir que listas não têm dimensão. mtcars_como_lista &lt;- as.list(mtcars) class(mtcars_como_lista) ## [1] &quot;list&quot; dim(mtcars_como_lista) ## NULL Ter duas dimensões significa que devemos usar dois índices para acessar os valores de um data frame (fazer subsetting). Para isso, ainda usamos o colchete, mas agora com dois argumentos: [linha, coluna]. mtcars[2, 3] ## [1] 160 O código acima está nos devolvendo o valor presente na segunda linha da terceira coluna da base mtcars. Também podemos pegar todos as linhas de uma coluna ou todas as colunas de uma linha deixando um dos argumentos vazio: # Todas as linhas da coluna 1 mtcars[,1] ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 # Todas as colunas da linha 1 mtcars[1,] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Por fim, lembrando que dento de cada coluna temos um vetor, podemos usar os testes lógicos para filtrar as linhas do nosso data frame conforme alguma regra. mtcars$cyl == 4 ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE ## [25] FALSE TRUE TRUE TRUE FALSE FALSE FALSE TRUE mtcars[mtcars$cyl == 4, ] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 O código mtcars$cyl == 4 nos diz em quais linhas estão os carros com 4 cilindros. Quando usamos o vetor de TRUE e FALSE resultante dentro do subsetting das linhas em mtcars[mtcars$cyl == 4, ], o R nos devolve todos as colunas dos carros com 4 cilindros. A regra é simples: linha com TRUE é retornada, linha com FALSE não. Encerramos aqui a nossa primeira conversa sobre data frames para falar de outra estrutura muito importante dentro do R: as funções. Exercícios 1. Quais códigos abaixo retornam um vetor com a coluna mpg do data frame mtcars? a. mtcars$mpg b. mtcars[ , 3] c. mtcars(\"mpg\") d. mtcars[ , \"mpg\"] e. mtcars.mpg f. mtcars[ , 1] g. mtcars[1, 1] h. mpg$mtcars 2. Para que serve a função str(). Dê um exemplo do seu uso. 3. Para que serve a função nanes(). Dê um exemplo do seu uso. 4. Use o data frame airquality para responder às questões abaixo: a. Quantas colunas airquality tem? b. Quantas linhas airquality tem? c. O que a função head() retorna? d. Quais são os nomes das colunas? e. Qual é a classe da coluna Ozone? 5. Desafio. Calculando desvio-padrão no R. Use o data frame airquality para responder às questões abaixo: a. Tire a média da coluna Ozone e guarde em um objeto. b. Guarde em um objeto o vetor correspondente à coluna Ozone subtraída da sua própria média (calculada em no item a). c. Eleve o vetor calculado em (b) ao quadrado. Salve o resultado em um novo objeto. d. Tire a média do vetor calculado em (c) e salve o resultado em um objeto chamado variancia. Em seguida, calcule a raiz quadrada desse valor e salve em um objeto chamado desvio_padrao. e. Compare o valor de desvio_padrao com sd(airquality$Ozone) e pesquise por que os valores não são iguais. Dica: veja a documentação da função sd(). 6. Use o data frame airquality para responder às questões abaixo. a. Conte quantos NAs tem na coluna Solar.R. b. Filtre a tabela airqualitycom apenas linhas em que Solar.R é NA. c. Filtre a tabela airquality com apenas linhas em que Solar.R não é NA. d. Filtre a tabela airquality com apenas linhas em que Solar.R não é NA e Month é igual a 5. Também existem bases não retangulares, como dados de imagens por exemplos, mas não trataremos dessas estruturas neste livro.↩︎ Mesmo quando uma variável não existe para uma unidade amostral, representamos esse valor como um missing↩︎ "],["3-11-maisFuncoes.html", "3.11 Mais sobre funções", " 3.11 Mais sobre funções Funções são tão comuns e intuitivas (provavelmente você já usou funções no Excel), que mesmo sem termos abordado o tema com detalhes, nós conseguimos utilizar várias funções nas seções anteriores: a função c() foi utilizada para criar vetores; a função class() foi utilizada para descobrir a classe de um objeto; a família de funções is.na(), is.nan(), is.infinite() e is.null foram utilizadas para testar se um valor é NA, NaN, infinito ou NULL, respectivamente. Diferentemente dos objetos, as funções podem receber argumentos. Argumentos são os valores que colocamos dentro dos parênteses e que as funções precisam para funcionar (calcular algum resultado). Por exemplo, a função c() precisa saber quais são os valores que formarão o vetor que ela irá criar. c(1, 3, 5) ## [1] 1 3 5 Nesse caso, os valores 1, 3 e 5 são os argumentos da função c(). Os argumentos de uma função são sempre separados por vírgulas. Funções no R têm personalidade. Cada uma pode funcionar de um jeito diferente das demais, mesmo quando fazem tarefas parecidas. Por exemplo, vejamos a função sum(). sum(1, 3) ## [1] 4 Como você deve ter percebido, essa função retorna a soma de seus argumentos. Também podemos passar um vetor como argumento, e ela retornará a soma dos elementos do vetor. sum(c(1, 3)) ## [1] 4 Já a função mean(), que calcula a média de um conjunto de valores, exige que você passe valores na forma de um vetor: # Só vai considerar o primeiro número na média mean(1, 3) ## [1] 1 # Considera todos os valores dentro do vetor na média mean(c(1, 3)) ## [1] 2 Como cada coluna de um data frame é um vetor, podemos calcular a média de uma coluna fazendo: # Podemos passar esse vetor para a função mean() mean(mtcars$mpg) ## [1] 20.09062 Também podemos usar argumentos para modificar o comportamento de uma função. O que acontece se algum elemento do vetor for NA? mean(c(1, 3, NA)) ## [1] NA Como a função não sabe o valor do terceiro elemento do vetor, ela não sabe qual é a média desses 3 elementos e, então, devolve NA. Como é muito comum termos NA nas nossas bases de dados, é muito comum tentarmos calcular a média de uma coluna que tem NA e recebermos NA como resposta. Na grande maioria dos casos, queremos saber a média de uma coluna apesar dos NAs. Isto é, queremos retirar os NAs e então calcular a média com os valores que conhecemos. Para isso, podemos utilizar o argumento na.rm = TRUE da função mean(). mean(c(1, 3, NA), na.rm = TRUE) ## [1] 2 Esse argumento diz à função para remover os NAs antes de calcular a média. Assim, a média calculada é: (1 + 3)/2. Claro que cada função tem os seus próprios argumentos e nem toda função terá o argumento na.rm=. Para saber quais são e como usar os argumentos de uma função, basta acessar a sua documentação: help(mean) Os argumentos das funções também têm nomes, que podemos ou não usar na hora de usar uma função. Veja por exemplo a função seq(). seq(from = 4, to = 10, by = 2) ## [1] 4 6 8 10 Entre outros argumentos, ela possui os argumentos from=, to= e by=. O que ela faz é criar uma sequência (vetor) de by em by que começa em from e termina em to. No exemplo, criamos uma função de 2 em 2 que começa em 4 e termina em 10. Também poderíamos usar a mesma função sem colocar o nome dos argumentos: seq(4, 10, 2) ## [1] 4 6 8 10 Para utilizar a função sem escrever o nome dos argumentos, você precisa colocar os valores na ordem em que os argumentos aparecem. E se você olhar a documentação da função seq(), fazendo help(seq), verá que a ordem dos argumentos é justamente from=, to= e by=. Escrevendo o nome dos argumentos, não há problema em alterar a ordem dos argumentos: seq(by = 2, to = 10, from = 4) ## [1] 4 6 8 10 Mas se especificar os argumentos, a ordem importa. Veja que o resultado será diferente. seq(2, 10, 4) ## [1] 2 6 10 A seguir, apresentamos algumas funções nativas do R úteis para trabalhar com data frames : head() - Mostra as primeiras 6 linhas. tail() - Mostra as últimas 6 linhas. dim() - Número de linhas e de colunas. names() - Os nomes das colunas (variáveis). str() - Estrutura do data frame. Mostra, entre outras coisas, as classes de cada coluna. cbind() - Acopla duas tabelas lado a lado. rbind() - Empilha duas tabelas. Além de usar funções já prontas, você pode criar a sua própria função. A sintaxe é a seguinte: nome_da_funcao &lt;- function(argumento_1, argumento_2) { # Código que a função irá executar } Repare que function é um nome reservado no R, isto é, você não pode criar um objeto com esse nome. Um exemplo: vamos criar uma função que soma dois números. minha_soma &lt;- function(x, y) { soma &lt;- x + y soma # resultado retornado } Essa função tem os seguintes componentes: minha_soma: nome da função x e y: argumentos da função soma &lt;- x + y: operação que a função executa soma: valor retornado pela função Após rodarmos o código de criar a função, podemos utilizá-la como qualquer outra função do R. minha_soma(2, 2) ## [1] 4 O objeto soma só existe dentro da função, isto é, além de ele não ser colocado no seu environment, ele só existirá na memória (RAM) enquanto o R estiver executando a função. Depois disso, ele será apagado. O mesmo vale para os argumentos x e y. O valor retornado pela função representa o resultado que receberemos ao utilizá-la. Por padrão, a função retornará sempre a última linha de código que existir dentro dela. No nosso exemplo, a função retorna o valor contido no objeto soma, pois é isso que fazemos na última linha de código da função. Repare que se atribuirmos o resultado a um objeto, ele não será mostrado no console: resultado &lt;- minha_soma(3, 3) # Para ver o resultado, rodamos o objeto `resultado` resultado ## [1] 6 Agora, o que acontece se a última linha da função não devolver um objeto? Veja: minha_nova_soma &lt;- function(x, y) { soma &lt;- x + y } A função minha_nova_soma() apenas cria o objeto soma, sem retorná-lo como na função minha_soma(). Se utilizarmos essa nova função, nenhum valor é devolvido no console: minha_nova_soma(1, 1) No entanto, a última linha da função agora é a atribuição soma &lt;- x + y e esse será o “resultado retornado”. Assim, podemos visualizar o resultado da função fazendo: resultado &lt;- minha_nova_soma(1, 1) resultado ## [1] 2 É como se, por trás das cortinas, o R estivesse fazendo resultado &lt;- soma &lt;- x + y, mas apenas o objeto resultado continua existindo, já que os objetos soma, xe y são descartados após a função ser executada. Claro que, na prática, é sempre bom criarmos funções que retornem na tela os seus resultados, para evitar esse passo a mais se quisermos apenas ver o resultado no console. Assim, a função minha_soma() costuma ser preferível com relação à função minha_nova_soma(). Exercícios 1. Qual dos códigos abaixo devolverá um erro se for avaliado? a. 3 * 5 + 10 b. function &lt;- 10 c. mean(1, 10) d. (soma &lt;- sum(1, 1)) 2. Crie uma função que receba um número e retorne o quadrado deste número. 3. Crie uma função que receba 2 números e devolva a raiz quadrada da soma desses números. 4. Crie uma função que receba dois valores (numéricos) e devolva o maior deles. 5. Use a função runif() para criar uma função que retorne um número aleatório inteiro entre 0 e 10 (0 e 10 inclusive). Caso você não conheça a função runif(), rode help(runif) para ler a sua documentação. 6. Rode help(sample) para descobrir o que a função sample() faz. Em seguida a. use-a para escrever uma função que devolva uma linha aleatória de um data frame; b. generalize a função para retornar um número qualquer de linhas, escolhido pelo usuário. "],["3-12-controle-de-fluxo.html", "3.12 Controle de Fluxo", " 3.12 Controle de Fluxo Como toda boa linguagem de programação, o R possui estruturas de if, else, for e while. Esses controles de fluxo são muito importantes na hora de programar, pois nos permitem manipular de modo eficiente as ações do computador. A seguir, explicaremos para que servem e como utilizar cada uma dessas estruturas. 3.12.1 Condicionamento: if e else As estruturas if e else servem para executarmos um código apenas se uma condição (teste lógico) for satisfeita. No código abaixo, a função Sys.time(), que retorna a data/hora no momento da execução, só será avlaiada se o objeto x for igual a 1. # Não vai executar a função Sys.time() x &lt;- 2 if (x == 1) { Sys.time() } # Vai executar a função Sys.time() x &lt;- 1 if (x == 1) { Sys.time() } ## [1] &quot;2021-02-18 19:19:43 -03&quot; O R só vai executar o que está na expressão dentro das chaves {} se a expressão que estiver dentro dos parênteses () retornar TRUE. Veja outro exemplo: # Vai fazer a soma x &lt;- c(1, 3, 10, 15) if (class(x) == &quot;numeric&quot;) { sum(x) } ## [1] 29 # Não vai fazer a soma x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) if (class(x) == &quot;numeric&quot;) { sum(x) } Nesse exemplo, a soma só é executada se a classe do objeto x for numérica, isto é, se x for um vetor de números. Essa verificação poderia ser colocada dentro de uma função para evitarmos que ela retorne um erro. minha_soma &lt;- function(x, y) { if (class(x) == &quot;numeric&quot; &amp; class(y) == &quot;numeric&quot;) { x + y } } # Retorna a soma minha_soma(1, 2) ## [1] 3 # Não retorna nada minha_soma(&quot;a&quot;, &quot;b&quot;) Nesses casos, é muito comum o uso das funções return() e stop() para, respectivamente, retornar um resultado antecipadamente ou para a execução da função e devolver ao usuário uma mensagem de erro personalizada. Um exemplo usando return(). # Devolvendo um resultado antecipadamente minha_soma_NA &lt;- function(x, y) { if (class(x) == &quot;numeric&quot; &amp; class(y) == &quot;numeric&quot;) { soma &lt;- x + y return(soma) } NA } # Retorna a soma minha_soma_NA(1, 2) ## [1] 3 # Retorna NA minha_soma_NA(&quot;a&quot;, &quot;b&quot;) ## [1] NA # Retorna NA minha_soma_NA(1, &quot;b&quot;) ## [1] NA Na função minha_soma_NA(), a soma só é calculada e retornada se x e y forem numéricos. Caso pelo menos um dos dois não seja, o código dentro do if não é executado e o valor retornado é o NA. Agora, usando stop(). # Agora, devolvendo um erro minha_soma_erro &lt;- function(x, y) { if (class(x) != &quot;numeric&quot; | class(y) != &quot;numeric&quot;) { stop(&quot;A classe dos objetos x e y deve ser numérica.&quot;) } x + y } # Retorna a soma minha_soma_erro(1, 2) ## [1] 3 # Retorna erro minha_soma_erro(&quot;a&quot;, &quot;b&quot;) ## Error in minha_soma_erro(&quot;a&quot;, &quot;b&quot;): A classe dos objetos x e y deve ser numérica. # Retorna erro minha_soma_erro(1, &quot;b&quot;) ## Error in minha_soma_erro(1, &quot;b&quot;): A classe dos objetos x e y deve ser numérica. Na função minha_soma_erro(), testamos no if se a classe de x ou a classe de y é diferente de numeric, isto é, se pelo menos um dos dois não é um número. Se esse teste retornar TRUE, a função para a sua execução e devolve para o usuário a seguinte mensagem de erro: “A classe dos objetos x e y deve ser numérica.”. Se o teste retorna FALSE, a soma é realizada e seu resultado nos é retornado. O else funciona como uma extensão do if, dando uma alternativa caso o teste executado seja falso. # Vai fazer a soma x &lt;- c(1, 3, 10, 15) if (class(x) == &quot;numeric&quot;) { sum(x) } else { NA } ## [1] 29 # Vai retornar NA x &lt;- c(1, 3, 10, &quot;15&quot;) if (class(x) == &quot;numeric&quot;) { sum(x) } else { NA } ## [1] NA Também podemos usar o else para encadear vários ifs. Teste o código abaixo com valores positivos e negativos para x. x &lt;- 0 if(x &lt; 0) { &quot;negativo&quot; } else if(x == 0) { &quot;neutro&quot; } else if(x &gt; 0) { &quot;positivo&quot; } ## [1] &quot;neutro&quot; Repare que o if no último else poderia ser omitido. x &lt;- 0 if(x &lt; 0) { &quot;negativo&quot; } else if(x == 0) { &quot;neutro&quot; } else { &quot;positivo&quot; } ## [1] &quot;neutro&quot; 3.12.2 Iteradores: for e while O for pode ser utilizado para fazer os famosos loopings de programação, isto é, repetir uma mesma tarefa para um conjunto de valores diferentes. Cada repetição é chamada de iteração e o objeto que muda de valor em cada interação é chamado de iterador. numero_de_colunas &lt;- ncol(mtcars) for (coluna in 1:numero_de_colunas) { media &lt;- mean(mtcars[,coluna]) print(media) } ## [1] 20.09062 ## [1] 6.1875 ## [1] 230.7219 ## [1] 146.6875 ## [1] 3.596563 ## [1] 3.21725 ## [1] 17.84875 ## [1] 0.4375 ## [1] 0.40625 ## [1] 3.6875 ## [1] 2.8125 O código acima vai calcular a média de cada coluna do data frame mtcars. Alguns pontos importantes: No exemplo, temos 11 iterações e o objeto coluna é o iterador. Como numero_de_colunas é igual a 11, a expressão 1:numero_de_colunas cria uma sequência de números de 1 a 11. A expressão coluna in 1:numero_de_colunas indica que o valor de coluna será 1 na primeira iteração, 2 na segunda iteração, 3 na terceira e assim por diante. O código dentro do for não é retornado para o usuário ao fim de cada iteração. Por isso, para ver os resultados no Console, usamos a função print(). Também podemos salvar as médias em um vetor. numero_de_colunas &lt;- ncol(mtcars) # Antes, criamos um vetor vazio. medias &lt;- c() for (coluna in 1:numero_de_colunas) { medias[coluna] &lt;- mean(mtcars[,coluna]) } medias ## [1] 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 ## [7] 17.848750 0.437500 0.406250 3.687500 2.812500 Assim como o for, o while também é um iterador. O código a seguir irá imprimir na tela o valor de i enquanto este objeto for menor que 3. No momento em que a condição dentro das chaves {} não for mais respeitada, o processo será interrompido. i &lt;- 1 while (i &lt; 3){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 É importante que o valor de i seja atualizado em cada interação, caso contrário a função entrará em um loop infinito. Por isso fazemos i &lt;- i + 1 após o print. Exercícios 1. Por que o código abaixo retorna erro? Arrume o código para retornar o valor TRUE. x &lt;- 4 if(x = 4) { TRUE } 2. Usando if e else, escreva um código que retorne a string \"número\" caso o valor seja da classe numeric ou integer; a string \"palavra\" caso o valor seja da classe character; e NA caso contrário. 3. Usando apenas for e a função length(), construa uma função que calcule a média de um vetor número qualquer. Construa uma condição para a função retornar NULL caso o vetor não seja numérico. 4. Utilize o vetor a para resolver as questões a seguir: a &lt;- c(10, 3, 5, -1, 3, -4, 8, 9, -10) a. Utilize o for para imprimir as médias acumuladas do vetor a, isto é, primeiro vamos imprimir 10, depois a média entre 10 e 3, depois a média entre 10, 3 e 5 e assim por diante. b. Adapte o laço que você fez no item anterior para ignorar os valores negativos, isto é, em caso de valor negativo, o laço não deve calcular a média e não imprimir nada. "],["3-13-outros-tópicos.html", "3.13 Outros tópicos", " 3.13 Outros tópicos Nesta seção, apresentamos alguns tópicos extras. Alguns deles serão retomanos em capítulos posteriores. 3.13.1 Matrizes As matrizes no R podem ser tratadas como vetores com duas dimensões. Por serem vetores, elas só podem conter elementos de uma mesma classe. Por possuírem duas dimensões, as operações de subsetting devem ser realizadas utilizando a sintaxe matriz[linha, coluna]. Para criar uma matriz, utilizamos a função matrix(). Precisamos definir quais elementos formarão a matriz e qual será o número de linhas e colunas. # Uma matriz de 2 linhas e 3 colunas m &lt;- matrix(1:9, nrow = 3, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 dim(m) ## [1] 3 3 Repare que os números de 1 a 9 foram dispostos na matriz coluna por coluna (column-wise), ou seja, preenchendo de cima para baixo e depois da esquerda para a direita. Esse comportamento pode ser alterado se utilizarmos o argumento byrow=. matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Subsetting de matrizes é muito parecido com o de data frames. # Seleciona a terceira linha m[3, ] ## [1] 3 6 9 # Seleciona a segunda coluna m[ , 2] ## [1] 4 5 6 # Seleciona o primeiro elemento da segunda coluna m[1, 2] ## [1] 4 A seguir, apresentamos algumas operações úteis para trabalhar com matrizes. # Matriz transposta t(m) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 # Matriz identidade 3 por 3 n &lt;- diag(3) n ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 # Multiplicação por escalar n * 2 ## [,1] [,2] [,3] ## [1,] 2 0 0 ## [2,] 0 2 0 ## [3,] 0 0 2 # Multiplicação matricial m %*% n ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Matriz inversa de m n2 &lt;- n * 2 solve(n2) ## [,1] [,2] [,3] ## [1,] 0.5 0.0 0.0 ## [2,] 0.0 0.5 0.0 ## [3,] 0.0 0.0 0.5 3.13.2 Fatores Fatores são uma classe de objetos no R criada para representar as variáveis categóricas numericamente. Essa classe possui um atributo especial: os levels. Levels são nada mais do que as categorias possíveis de uma variável categórica. Como exemplo, imagine que o objeto sexo guarde uma coluna que indica o sexo de uma pessoa: F para feminino e M para masculino. Normalmente, essa coluna seria importada para o R como texto. Podemos transformá-la em fator utilizando a função as.factor(). # Variável sexo como texto sexo &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;) sexo ## [1] &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; # Variável sexo, como fator as.factor(sexo) ## [1] F M M M F F M ## Levels: F M Repare que a saída do objeto sexo quando o transformamos em fator tem uma informação a mais. Na última linha, visualizamos os levels desse fator, isto é, um conjunto das categorias possíveis do fator sexo (no caso, F e M). Por padrão, os levels são ordenados por ordem alfabética. Veremos mais adiante que isso pode fazer diferença na construção de gráficos e na aplicação de modelos. A diferença entre fatores e texto dentro do R é como eles são representados internamente. Enquanto objetos da classe character realmente são representados como texto, fatores são representados como números inteiros. # Em geral, não é possível transforma textos em números as.numeric(sexo) ## Warning: NAs introduced by coercion ## [1] NA NA NA NA NA NA NA # Mas podemos transforrma fatores em inteiros fator &lt;- as.factor(sexo) as.numeric(fator) ## [1] 1 2 2 2 1 1 2 Internamente, cada level de um fator é representado como um inteiro. No exemplo anterior, o level F está sendo representado como 1 e o level M como 2. Se um fator tiver 10 levels, teremos os inteiros de 1 a 10 representando esse fator. # letters é um objeto nativo do R letras &lt;- letters[1:10] fator &lt;- as.factor(letras) fator ## [1] a b c d e f g h i j ## Levels: a b c d e f g h i j as.numeric(fator) ## [1] 1 2 3 4 5 6 7 8 9 10 O texto que vemos quando avaliamos um fator (F e M em vez de 1 e 2, por exemplo) é apenas uma “etiqueta” que o R coloca em cima dos inteiros. As diferentes etiquetas de um fator são justamente os levels. Como fatores são sempre representados interrnamente por inteiros sequencias começando do 1 (1, 2, 3, …) e esses inteiros são sempre atribuídos conforme a ordem alfabética dos levels, um erro muito comum é tentar transformar levels numéricos em números: # Texto vetor &lt;- c(&quot;10&quot;, &quot;55&quot;, &quot;55&quot;, &quot;12&quot;, &quot;10&quot;, &quot;-5&quot;, &quot;-90&quot;) vetor ## [1] &quot;10&quot; &quot;55&quot; &quot;55&quot; &quot;12&quot; &quot;10&quot; &quot;-5&quot; &quot;-90&quot; # Fator fator &lt;- as.factor(vetor) fator ## [1] 10 55 55 12 10 -5 -90 ## Levels: -5 -90 10 12 55 # Número as.numeric(fator) ## [1] 3 5 5 4 3 1 2 Quando transformamos o objeto vetor em um fator, o R não enxerga os “números” dentro dele. Para o R, é tudo texto. Então, como nos outros exemplos, cada “número” será representado por um inteiro, atribuído pela ordem alfabética. Uma forma de evitar esse problema é transformar o fator em texto antes de transformá-lo em número. # Voltando para texto texto &lt;- as.character(fator) texto ## [1] &quot;10&quot; &quot;55&quot; &quot;55&quot; &quot;12&quot; &quot;10&quot; &quot;-5&quot; &quot;-90&quot; # Agora sim os números originais as.numeric(texto) ## [1] 10 55 55 12 10 -5 -90 3.13.3 Gráficos (R base) O R já vem com funções básicas que fazem gráficos estatísticos de todas as naturezas. Vantagens: são rápidas e simples. Desvantagens: os gráficos são simplórios e geralmente é difícil gerar gráficos mais elaborados. Nesta seção, mostraremos como construir alguns tipos de gráficos usando as funções base do R, mas o nosso foco em visualização de dados está nas funções do pacote ggplot2, apresentadas no Capítulo 8. Gráfico de dispersão e linhas Para construir um gráfico de dispersão, utilizamos a função plot(). Seus principais parâmetros são: x, y: vetores para representarem os eixos x e y. type: tipo de gráfico. Pode ser pontos, linhas, escada, entre outros. Para mais detalhes sobre os argumentos, ver help(plot). N &lt;- 100 x &lt;- 1:N y &lt;- 5 + 2 * x + rnorm(N, sd = 30) plot(x, y) No código acima, a função rnorm() gera uma amostra aleatória da distribuição Normal com média 0 e desvio-padrão 30. O parâmetro type = \"l\" indica que queremos que os pontos sejam interligados por linhas. plot(x, y, type = &quot;l&quot;) Histograma Para construir histogramas, utilizamos a função hist(). Os principais parâmetros são: x: o vetor numérico para o qual o histograma será construído. breaks: número (aproximado) de retângulos. hist(rnorm(1000)) hist(rnorm(1000), breaks = 6) Boxplot Para construir boxplots, utilizamos a função boxplot(). Os principais parâmetros são: x: o vetor numérico para o qual o boxplot será construído. boxplot(mtcars$mpg, col = &quot;lightgray&quot;) Observe que o argumento col= muda a cor da caixa do boxplot. Para mapear duas variáveis ao gráfico, passamos um data frame para o argumento data= e utilizamos a seguinte sintaxe var_numerica ~ var_categorica. boxplot(mpg ~ cyl, data = mtcars, col = &quot;purple&quot;) Gráfico de barras Para construir gráficos de barras, precisamos combinar as funções table() e barplot(). No gráfico abaixo, primeiro criamos uma tabela de frequências com a função table() e, em seguida, construímos o gráfico com a função barplot(). tabela &lt;- table(mtcars$cyl) tabela ## ## 4 6 8 ## 11 7 14 barplot(tabela) "],["4-pacotes.html", "Capítulo 4 Pacotes", " Capítulo 4 Pacotes A primeira aparição da linguagem de progromação R foi em 1993 e, apesar de lá para cá muita coisa ter sido desenvolvida e atualizada, é muito difícil fazer mudanças na base da linguagem sem quebrar os códigos já existentes. Por essa razão, as maiores inovações são realizadas na forma de pacotes. Um pacote é um conjunto de funções que têm como objetivo resolver um problema específico. São eles que deixam o R poderoso, capaz de enfrentar qualquer tarefa de análise de dados. Assim, fique bastante à vontade para instalar e atualizar muitos e muitos pacotes ao longo da sua experiência com o R. O legal é que qualquer pessoa pode fazer um novo pacote e disponibilizar para a comunidade, o que acelera bastante o desenvolvemento da ferramenta. Dificilmente você vai fazer uma análise apenas com as funções básicas do R e dificilmente não vai existir um pacote com as funções que você precisa. "],["4-1-instalação-de-pacotes.html", "4.1 Instalação de pacotes", " 4.1 Instalação de pacotes Existem três principais maneiras de instalar pacotes. Em ordem de frequência, são: Via CRAN (Comprehensive R Archive Network): install.packages(\"nome-do-pacote\"). Via Github: devtools::install_github(\"nome-do-repo/nome-do-pacote\"). Via arquivo .zip/.tar.gz: install.packages(\"C:/caminho/nome-do-pacote.zip\", repos = NULL). Para conseguir instalar alguns pacotes no Linux, você pode precisar instalar dependências do sistema manualmente. Por exemplo, se você quer instalar o pacote devtools no R, será necessário ter as bibliotecas curl, openssl, httr e git2r. Essas dependências geralmente podem ser instaladas no terminal por meio do comando apt-get install nome-da-biblioteca. Caso você não consiga instalar um pacote devido a ausência de uma dependência, uma maneira de saber quais bibliotecas você precisa instalar é observar as mensagens que aparecem no console durante a tentativa da instalação do pacote. 4.1.1 Via CRAN Instale pacotes que não estão na sua biblioteca usando a função install.packages(\"nome_do_pacote\"). Por exemplo: install.packages(&quot;tidyverse&quot;) E, de agora em diante, não precisa mais instalar. Basta carregar o pacote com library(magrittr). Escreva nome_do_pacote::nome_da_funcao() se quiser usar apenas uma função de um determinado pacote. O operador :: serve para isso. Essa forma também é útil quando se tem duas funções com o mesmo nome e precisamos garantir que o código vá usar a função do pacote correto. 4.1.2 Via Github Desenvolvedores costumam disponibilizar a última versão de seus pacotes no Github, e alguns deles sequer estão no CRAN. Mesmo assim ainda é possível utilizá-los instalando diretamente pelo github. O comando é igualmente simples: devtools::install_github(&quot;rstudio/shiny&quot;) Apenas será necessário o username e o nome do repositório (que geralmente tem o mesmo nome do pacote). No exemplo, o username foi “rstudio” e o repositório foi “shiny”. Se você não é familiar com o github, não se preocupe! Os pacotes disponibilizados na plataforma geralmente têm um README cuja primeira instrução é sobre a instalação. Se não tiver, provavelmente este pacote não te merece! =) 4.1.3 Via arquivo .zip ou .tar.gz Se você precisar instalar um pacote que está zipado no seu computador (ou em algum servidor), utilize o seguinte comando: install.packages(&quot;C:/caminho/para/o/arquivo/zipado/nome-do-pacote.zip&quot;, repos = NULL) É semelhante a instalar pacotes via CRAN, com a diferença que agora o nome do pacote é o caminho inteiro até o arquivo. O parâmetro repos = NULL informa que estamos instalando a partir da máquina local. A aba Packages do RStudio também ajuda a administrar os seus pacotes. "],["4-2-tidyverse.html", "4.2 Tidyverse", " 4.2 Tidyverse Muitas pessoas tentam definir o que é ciência de dados no mercado e na academia. O problema é que esse termo pode ser descrito de várias formas distintas, seja pela formação específica da pessoa que define ou do interlocutor ao qual ela se comunica. Por isso, a definição de ciência de dados é, de certa forma, vazia. No entanto, é possível definir como se faz ciência de dados. Ou seja, independentemente da definição do termo, o que temos de fazer na prática em projetos reais é algo bastante conhecido. O “como faz” é definido através do Ciclo da Ciência de Dados, descrito na Figura 4.1. Primeiro, os dados brutos são coletados de fontes públicas, como arquivos Excel, portais de dados abertos ou bases de dados internos da companhia. Em seguida, os dados são arrumados, para mitigar problemas de padronização de nomes, obtenção das variáveis de interesse e exclusão de casos que estão fora do escopo de análise, produzindo o que se define como base de dados analítica. A base analítica é então transformada para produzir as tabelas e gráficos e, quando necessário, são utilizadas como insumo para o ajuste de modelos estatísticos. Finalmente, os resultados obtidos são comunicados através de uma série de ferramentas, como relatórios, dashboards interativos, indicadores ou Application Programming Interfaces (API) para automação. Figura 4.1: O Ciclo da Ciência de Dados. O {tidyverse} é um pacote guarda-chuva que consolida uma série de ferramentas que fazem parte o ciclo da ciência de dados. Fazem parte do {tidyverse} os pacotes {ggplot2}, {dplyr}, {tidyr}, {purrr}, {readr}, entre muitos outros, como é possível observar na Figura 4.2. Veremos as características principais desses pacotes nas próximas Seções. Figura 4.2: A implementação do Ciclo da Ciência de Dados, através do tidyverse. Pela definição estrita do tidyverse, na imagem não fazem parte do tidyverse os pacotes janitor, data.table e os pacotes descritos nas partes de modelagem, comunicação e automatização. No entanto, a maioria desses pacotes também seguem os princípios tidy e podem ser usados em conjunto com o tidyverse sem grandes dificuldades. O {tidyverse} traz consigo o manifesto tidy. Trata-se de um documento que formaliza uma série de princípios que norteiam o desenvolvimento do tidyverse. Como os pacotes do {tidyverse} compartilham os mesmos princípios, podem ser utilizados naturalmente em conjunto. Pode-se dizer que existe uma linguagem R antes e outra depois do {tidyverse}. A linguagem mudou muito, a comunidade abraçou uso desses princípios e criou centenas de novos pacotes que conversam uns com os outros dessa forma.9 Os princípios fundamentais do tidyverse são: Reutilizar estruturas de dados existentes. Organizar funções simples usando o pipe (Seção 6). Aderir à programação funcional (Seção 10). Projetado para ser usado por seres humanos. No texto do manifesto tidy cada um dos lemas é descrito de forma detalhada. No nosso blog, selecionamos os aspectos que achamos mais importante de cada um deles. Na prática, carregar o (veja o código abaixo) é o mesmo que carregar os seguintes pacotes: {tibble} para data frames repaginados; {readr} para importarmos bases para o R; {tidyr} e {dplyr} para arrumação e manipulação de dados; {stringr} para trabalharmos com textos; {forcats} para trabalharmos com fatores; {ggplot2} para gráficos; {purrr} para programação funcional. Embora o {tidyverse} instale diversos outros pacotes, apenas esses são carrregados. Dificilmente fazemos uma análise de dados em que não precisamos usá-los. Falaremos com mais detalhes de todos eles neste livro. library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Mensagens de conflito quando carregamos o {tidyverse} ou qualquer outro pacote significam que funções anteriormente carregadas foram mascaradas por novas funções. No exemplo acima, as funções filter() e lag() do pacote stats foram substituídas na sessão pelas funções filter() e lag() do pacote dplyr. Nesse caso, se quiséssemos usar as funções do pacote stats após carregar o {tidyverse}, precisaríamos rodar stats::filter() e stats::lag(). Se você quiser descarregar um pacote, reinicie a sua sessão em Session &gt; Restart R ou use a função detach() como no exemplo abaixo. detach(&quot;package:tidyverse&quot;, unload = TRUE) Usar a filosofia tidy não é a única forma de fazer pacotes do R. Existem muitos pacotes excelentes que não utilizam essa filosofia. O próprio manifesto diz “O contrário de tidyverse não é o messyverse, e sim muitos outros universos de pacotes interconectados.”↩︎ "],["5-importacao.html", "Capítulo 5 Importação", " Capítulo 5 Importação Nesta seção, vamos introduzir os principais pacotes para importar dados para o R. Mostraremos como importar dados de arquivos de texto, planilhas do excel e extensões de outros programas estatísticos (SAS e SPSS, por exemplo). Antes de começarmos, vale a pena destacarmos um ponto importante. As funções de importação do tidyverse importam dados em objetos da classe tibble, que difere da classe data.frame usual em dois pontos importantes: imprime os dados na tela (Console) de maneira muito mais organizada, resumida e legível; permite a utilização de list-columns. Se você não estiver familiarizado com o conceito de list-columns, não se preocupe. Trataremos melhor do assunto no Capítulo 10. "],["5-1-caminhos.html", "5.1 Caminhos", " 5.1 Caminhos Um passo importante na tarefa de importação de dados para o R é saber onde está o arquivo que queremos importar. Toda função de importação vai exigir um caminho, uma string que representa o endereço do arquivo no computador. Há duas formas de passarmos o caminho de arquivo: usar o caminho absoluto ou usar o caminho relativo. Antes de falarmos sobre a diferença dos dois, precisamos definir o que é o diretório de trabalho. O diretório de trabalho (working directory) nada mais é do que a pasta em que o R vai procurar arquivos na hora de ler informações ou gravar arquivos na hora de salvar objetos. Se você está usando um projeto, o diretório de trabalho da sua sessão será, por padrão, a pasta raiz do seu projeto (é a pasta que contém o arquivo com extensão .Rproj). Se você não estiver usando um projeto ou simplesmente não souber qual é o seu diretório de trabalho, você pode descobri-lo usando a seguinte função getwd(). Ela vai devolver uma string com o caminho do seu diretório de trabalho. A função setwd() pode ser utilizada para mudar o diretório de trabalho. Como argumento, ela recebe o caminho para o novo diretório. Caminhos absolutos são aqueles que tem início na pasta raiz do seu computador/usuário. Por exemplo: getwd() ## [1] &quot;/Users/william/Documents/curso-r/livro-material&quot; Esse é o caminho absoluto para a pasta onde esse livro foi produzido. Na grande maioria dos casos, caminhos absolutos são uma má prática, pois deixam o código irreprodutível. Se você trocar de computador ou passar o script para outra pessoa rodar, o código não vai funcionar, pois o caminho absoluto para o arquivo muito provavelmente será diferente. Caminhos relativos são aqueles que tem início no diretório de trabalho da sua sessão. Assim, se você quiser acessar um arquivo minha_base.csv dentro de uma pasta “dados” existente no seu diretório de trabalho, você poderia passar para o R o caminho \"dados/minha_base.csv\". Trabalhar com projetos no RStudio ajuda bastante o uso de caminhos relativos, pois nos incentiva a colocar todos os arquivos da análise dentro da pasta do projeto. Assim, se você usar apenas caminhos relativos e compartilhar a pasta do projeto com alguém, todos os caminhos existentes nos códigos continuarão a funcionar em qualquer computador! "],["5-2-readr.html", "5.2 O pacote readr", " 5.2 O pacote readr O pacote {readr}do tidyverse é utilizado para importar arquivos de texto, como .txt ou .csv, para o R. Para carregá-lo, rode o código: library(readr) O {readr} transforma arquivos de textos em tibbles usando as funções: read_csv(): para arquivos separados por vírgula. read_tsv(): para arquivos separados por tabulação. read_delim(): para arquivos separados por um delimitador genérico. O argumento delim= indica qual caracter separa cada coluna no arquivo de texto. read_table(): para arquivos de texto tabular com colunas separadas por espaço. read_fwf(): para arquivos compactos que devem ter a largura de cada coluna especificada. read_log(): para arquivos padrões de log. Vamos mostrar na próxima seção como importar as extensões mais comuns: .csv e .txt. 5.2.1 Lendo arquivos de texto Como exemplo, utilizaremos uma base de filmes do IMDB, gravada em diversos formatos. O download dos arquivos pode ser realizado a partir deste repositório. Primeiro, vamos ler a base em formato .csv. imdb_csv &lt;- read_csv(file = &quot;imdb.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## titulo = col_character(), ## ano = col_double(), ## diretor = col_character(), ## duracao = col_double(), ## cor = col_character(), ## generos = col_character(), ## pais = col_character(), ## classificacao = col_character(), ## orcamento = col_double(), ## receita = col_double(), ## nota_imdb = col_double(), ## likes_facebook = col_double(), ## ator_1 = col_character(), ## ator_2 = col_character(), ## ator_3 = col_character() ## ) A mensagem retornada pela função indica qual classe foi atribuída para cada coluna. Repare que o argumento file= representa o caminho até o arquivo. Se o arquivo a ser lido não estiver no diretório de trabalho da sua sessão, você precisa especificar o caminho até o arquivo. # Se o arquivo estiver dentro de uma pasta chamada dados. imdb_csv &lt;- read_csv(file = &quot;dados/imdb.csv&quot;) A maioria das funções de leitura do {readr} possuem argumentos muito úteis para resolver problemas de importação: col_names=: indica se a primeira linha da base contém ou não o nome das colunas. Também pode ser utilizado para (re)nomear colunas. col_types=: caso alguma coluna seja importada com a classe errada (uma coluna de números foi importada como texto, por exemplo), você pode usar esse argumento para especificar a classe das colunas. locale=: útil para tratar problema de encoding. skip=: pula linhas no começo do arquivo antes de iniciar a importação. Útil para quando o arquivo a ser importado vem com metadados ou qualquer tipo de texto nas primeiras linhas, antes da base. na=: indica quais strings deverão ser considaras NA na hora da importação. Em alguns países, como o Brasil, as vírgulas são utilizadas para separar as casas decimais dos números, inviabilizando o uso de arquivos .csv. Nesses casos, quando a vírgula é o separador de decimal, os arquivos .csv passam a ser separados por ponto-e-vírgula. Para importar bases de arquivos separados por ponto-e-vírgula no R, basta usar a função read_csv2(). imdb_csv2 &lt;- read_csv2(&quot;dados/imdb2.csv&quot;) Arquivos .txt em geral podem ser lidos com a função read_delim(). Além do caminho até o arquivo, você também precisa indicar qual é o caractere utilizado para separar as colunas da base. Um arquivo separado por tabulação, por exemplo, pode ser lido utilizando a o código abaixo. O código \\t é uma forma textual de representar a tecla TAB. imdb_txt &lt;- read_delim(&quot;dados/imdb.txt&quot;, delim = &quot;\\t&quot;) Repare que a sintaxe é igual a da função read_csv(). Em geral, as funções de importação do {tidyverse} terão sintaxe e comportamento muito parecidos. A seguir, vamos falar das funções parse_(), muito úteis para tratar problemas na classe das variáveis na hora da importação. 5.2.2 Locale Muitas funções de importação e formatação possuem um argumento locale. Esse argumento é utilizado para definir opções de formatação próprias de uma certa localidade, como idioma, formato de data e hora, fuso horário, separador de decimal e milhar ou encoding. O pacote {readr} possui uma função chamada locale(), que pode ser utilizada para definir todos esses atributos. Para saber quais são os padrões atualmente definidos na sua sessão, basta rodar: locale() ## &lt;locale&gt; ## Numbers: 123,456.78 ## Formats: %AD / %AT ## Timezone: UTC ## Encoding: UTF-8 ## &lt;date_names&gt; ## Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday ## (Thu), Friday (Fri), Saturday (Sat) ## Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), ## June (Jun), July (Jul), August (Aug), September (Sep), October ## (Oct), November (Nov), December (Dec) ## AM/PM: AM/PM Em geral, teremos padrões norte-americanos. Se quisermos que os nomes de dias e meses fiquem em português, podemos fazer: locale(date_names = &quot;pt&quot;) ## &lt;locale&gt; ## Numbers: 123,456.78 ## Formats: %AD / %AT ## Timezone: UTC ## Encoding: UTF-8 ## &lt;date_names&gt; ## Days: domingo (dom), segunda-feira (seg), terça-feira (ter), quarta-feira ## (qua), quinta-feira (qui), sexta-feira (sex), sábado (sáb) ## Months: janeiro (jan), fevereiro (fev), março (mar), abril (abr), maio (mai), ## junho (jun), julho (jul), agosto (ago), setembro (set), outubro ## (out), novembro (nov), dezembro (dez) ## AM/PM: AM/PM Ou trocar o separador de decimal de ponto para vírgula, caso a base a ser importada esteja nesse formato. locale(decimal_mark = &quot;,&quot;) ## &lt;locale&gt; ## Numbers: 123.456,78 ## Formats: %AD / %AT ## Timezone: UTC ## Encoding: UTF-8 ## &lt;date_names&gt; ## Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday ## (Thu), Friday (Fri), Saturday (Sat) ## Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), ## June (Jun), July (Jul), August (Aug), September (Sep), October ## (Oct), November (Nov), December (Dec) ## AM/PM: AM/PM A função locale() deve ser utilizada dentro das funções read_(), no argumento locale. Uma utilização muito comum é a definição do encoding do arquivo. O encoding se refere a como o computador traduz os caracteres que vemos na tela para os valores binários que ele utiliza internamente. Existem vários tipos de encoding e isso é um problema principalmente porque o Windows utiliza um encoding diferente do Linux/Mac. Você saberá que tem um problema de encoding quando letras com acento ou outros caracteres especiais ficarem desconfigurados após importar uma base para o R. # Vamos produzir um problema de encoding frase_com_acentos &lt;- &quot;Você comerá uma maçã amanhã à tarde&quot; # Vendo encoding. UTF-8 é o padrão do Linux/Mac Encoding(frase_com_acentos) ## [1] &quot;UTF-8&quot; # Forçando um novo encoding. # latin1 é um dos padrões que funcionam no Windows. Encoding(frase_com_acentos) &lt;- &quot;latin1&quot; # Agora temos um problema de encoding frase_com_acentos ## [1] &quot;VocÃª comerÃ¡ uma maÃ§Ã£ amanhÃ£ Ã tarde&quot; Quando estivermos enfrentando esse problema, devemos dizer à função read_() qual o encoding deve ser utilizado no arquivo. read_csv(&quot;base_que_veio_do_windows.csv&quot;, locale = locale(encoding = &quot;latin1&quot;)) O latin1 é apenas um dos encodings que podem funcionar em arquivos do Windows. Outras sugestões são: windows-1250, windows-1252, ISO-8859-2 e ISO-8859-1. Se você estiver lendo um arquivo cruado no Linux/Mac no Windows, basta usar o encoding UTF-8. Eu consegui resolver 99% dos meus problemas de encoding quando passei a fingir que o Windows não existe. — Julio Trecenti Na seção a seguir, mostramos mais alguns exemplos da função locale(). 5.2.3 Parseando valores O pacote {readr} possui algumas funções muito úteis para parsear valores. Parsear é um termo muito utilizado em programação e tem o sentido de arrumar ou formatar. Se estamos parseando um número, por exemplo, estamos pegando um texto que é muito parecido com um número e o transforando em um número de fato. parse_number(c(&quot;5&quot;, &quot;5.0&quot;, &quot;5,0&quot;, &quot;R$5.00&quot;, &quot;5 a&quot;)) ## [1] 5 5 50 5 5 Figura 5.1: Arte por Allison Horst (@allison_horst). Veja nas Referências onde encontrá-la. Veja que podemos usar o argumento locale para especificar coordenadas para o parseamento parse_number(&quot;5,0&quot;, locale = locale(decimal_mark = &quot;,&quot;)) ## [1] 5 ou o idioma usado em datas # Inglês parse_date( &quot;01/June/2010&quot;, format = &quot;%d/%B/%Y&quot; ) ## [1] &quot;2010-06-01&quot; # Português parse_date( &quot;01/Junho/2010&quot;, format = &quot;%d/%B/%Y&quot;, locale = locale(date_names = &quot;pt&quot;) ) ## [1] &quot;2010-06-01&quot; Você também pode especificar NAs utilizando o argumento na. parse_number(c(&quot;5&quot;, &quot;5.0&quot;, &quot;5,0&quot;, &quot;R$5.00&quot;, &quot;5 a&quot;), na = &quot;5 a&quot;) ## [1] 5 5 50 5 NA Outras funções de parseamento úteis são: readr::parse_integer(), para parsear números inteiros. readr::parse_character(), para parsear strings readr::parse_date(), readr::parse_time(), readr::parse_datetime()para parsear datas, horas e data/horas. Todas essas funções são utilizadas nas colunas de uma base quando utilizamos as funções de importação do {readr}. Assim, se algum valor foi modificado incorretamente durante a importação, você pode testar importar tudo como texto (character) e usar essas funções para reproduzir a transformação que o {readr} fez. 5.2.4 Escrevendo arquivos de texto Para a maioria das funções read_, existe uma respectiva função write_. Essas funções servem para salvar bases em um formato específico de arquivo. Além do caminho/nome do arquivo a ser criado, você também precisa passar o objeto que será escrito. Para o arquivo criado funcionar corretamente, você precisa especificar a extensão correta no nome do arquivo. # Arquivo .csv write_csv(x = mtcars, path = &quot;data/mtcars.csv&quot;) # Base separada por tabulação write_delim(x = mtcars, path = &quot;data/mtcars.txt&quot;, delim = &quot;\\t&quot;) 5.2.5 Arquivos .rds A linguagem R tem uma extensão própria de arquivos binários chamada RDS ou .rds. Essa extensão pode ser utilizada para guarda qualquer tipo de objeto do R, inclusive bases de dados. Temos duas principais vantagens ao utilizarmos essa extensão para salvarvamos as nossas bases: ele salva as classes especificadas para as colunas; ele pode ser compactado, gerando arquivos muito menores. A desvantagem é que ele só poderá ser lido dentro do R. Para criar um arquivo .rds, utilize a função write_rds(). write_rds(mtcars, path = &quot;mtcars.rds&quot;, compress = &quot;gz&quot;) O argumento compress é opcional e indica qual o tipo de compactação deve ser feito. O padrão é não compactar. Para ler um arquivo .rds de volta para o R, utilizamos a função read_rds(). Repare que essa função não possui outros argumentos, pois o objeto importado será exatamente igual ao objeto que foi gravado no arquivo. imdb_rds &lt;- read_rds(path = &quot;imdb.rds&quot;) Exercícios Qual a diferença entre as funções read_csv() e read_csv2()? Leia o arquivo imdb.csv utilizando a função read_delim(). Escreva a base mtcars em um arquivo mtcars.csv que não contenha o nome das colunas. Use a função write_rds() para salvar em arquivos Um número. Um vetor de strings. Uma lista com valores númericos, textuais e lógicos. As 3 primeiras colunas da base mtcars. Utilize a função read_rds() para importar de volta para o R os arquivos criados no exercício 4. "],["5-3-readxl.html", "5.3 Os pacotes readxl e writexl", " 5.3 Os pacotes readxl e writexl Para ler planilhas do Excel (arquivos .xlsx ou .xls), basta utilizarmos a função read_excel() do pacote readxl. Instale o pacote antes caso você ainda não o tenha instalado. install.packages(&quot;readxl&quot;) library(readxl) imdb_xlsx &lt;- read_xls(&quot;dados/imdb.xlss&quot;) imdb_xlsx &lt;- read_xlsx(&quot;dados/imdb.xlsx&quot;) A funçao read_excel() auto detecta a extensão do arquivo. read_excel(path = &quot;assets/data/imdb.xls&quot;) read_excel(path = &quot;assets/data/imdb.xlsx&quot;) O pacote disponibiliza 5 exemplos de arquivos com formato .xls e .xlsx. readxl_example() ## [1] &quot;clippy.xls&quot; &quot;clippy.xlsx&quot; &quot;datasets.xls&quot; &quot;datasets.xlsx&quot; ## [5] &quot;deaths.xls&quot; &quot;deaths.xlsx&quot; &quot;geometry.xls&quot; &quot;geometry.xlsx&quot; ## [9] &quot;type-me.xls&quot; &quot;type-me.xlsx&quot; Vamos pegar o caminho até o arquivo datasets.xlsx usando a função readxl_example(). caminho_datasets &lt;- readxl_example(&quot;datasets.xlsx&quot;) caminho_datasets ## [1] &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library/readxl/extdata/datasets.xlsx&quot; No Excel, um arquivo pode ter várias planilhas. Esse é o caso do arquivo datasets.xlsx. Você pode ver quais planilhas fazem parte do arquivo utilizando a função excel_sheets(). excel_sheets(caminho_datasets) ## [1] &quot;iris&quot; &quot;mtcars&quot; &quot;chickwts&quot; &quot;quakes&quot; Por padrão, as funções de leitura trarão apenas a primeira planilha do arquivo. Para trazer outra planilha, basta utilizarmos o argumento sheet. # Pega a primeira planilha read_excel(caminho_datasets) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows # Pega a segunda planilha read_excel(caminho_datasets, sheet = 2) ## # A tibble: 32 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows # Pega a planilha selecionada read_excel(caminho_datasets, sheet = &#39;chickwts&#39;) ## # A tibble: 71 x 2 ## weight feed ## &lt;dbl&gt; &lt;chr&gt; ## 1 179 horsebean ## 2 160 horsebean ## 3 136 horsebean ## 4 227 horsebean ## 5 217 horsebean ## 6 168 horsebean ## 7 108 horsebean ## 8 124 horsebean ## 9 143 horsebean ## 10 140 horsebean ## # … with 61 more rows A seguir, listamos outros argumentos úteis da função read_excel(): col_names indica se a primeira linha representa o nome das colunas; col_types= para definir a classe das colunas; skip= para pular linhas no começo da planilha; na= indica quais strings devem ser interpretadas como NA. Também podemos escrever um arquivo Excel (com extensão .xlsx) utilizando a função write_xlsx() do pacote writexl. install.packages(&quot;writexl&quot;) library(writexl) write_excel(mtcars, &quot;imdb.xlsx&quot;) "],["5-4-haven.html", "5.4 haven", " 5.4 haven Para ler arquivos gerados por outros softwares, como SPSS, SAS e STATA, você pode usar as funções do pacote haven. Este pacote faz parte do tidyverse e é um wrapper da biblioteca ReadStat, escrita em C. library(haven) imdb_sas &lt;- read_sas(&quot;assets/data/imdb.sas7bdat&quot;) imdb_spss &lt;- read_spss(&quot;assets/data/imdb.sav&quot;) imdb_dta &lt;- read_dta(&quot;assets/data/imdb.dta&quot;) É possível salvar ou escrever bases em SAS e STATA com as funções write_sas e write_dta. write_dta(mtcars, &#39;assets/data/mtcars.dta&#39;) Quando importamos arquivos gerados pelo SAS SPSS ou STATA para o R, os rótulos de uma variável podem não ser importados de forma correta. O pacote haven tem uma soluçao para este problema. x &lt;- labelled(c(1,1,2,3,2,2,1,2), c(Ruim = 1, Bom = 2, Otimo = 3)) labelled() adiciona rótulos à valores de uma variável. Para verificar quais são estes rótulos, podemos usar a função print_labels(). print_labels(x) ## ## Labels: ## value label ## 1 Ruim ## 2 Bom ## 3 Otimo Existe uma função similar a labelled(), exclusiva para o SPSS, que além de rotular as variáveis, também defini quais símbolos representam valores faltantes, dado que em SPSS pode haver mais de um tipo de missing. x1 &lt;- labelled_spss(c(1,3,0,2,2,1,0,2,4), c(Ruim = 1,Bom = 2, Otimo = 3), na_values = c(0,4)) is.na(x1) ## [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE TRUE Agora que já definimos os missings “especiais”, podemos transformá-los no missing padrão do R, representado pelo símbolo NA. x1 &lt;- zap_missing(x1) x1 ## [1] 1 3 NA 2 2 1 NA 2 NA ## attr(,&quot;labels&quot;) ## Ruim Bom Otimo ## 1 2 3 ## attr(,&quot;class&quot;) ## [1] &quot;haven_labelled&quot; Existem outras funções zap_ interessantes no pacote. Após rotular os valores do vetor, podemos convertê-los, por exemplo, em fator. Para isso, usamos uma função do pacote haven. A função base as.factor() também poderia ser usada, mas quando a usamos, os rótulos não são considerados. x_base &lt;- base::as.factor(x) levels(x_base) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; x_factor &lt;- haven::as_factor(x) levels(x_factor) ## [1] &quot;Ruim&quot; &quot;Bom&quot; &quot;Otimo&quot; "],["6-pipe.html", "Capítulo 6 Pipe", " Capítulo 6 Pipe O operador %&gt;% (pipe) foi uma das grandes revoluções recentes do R, tornando a escrita e leitura de códigos mais intuitiva e compreensível. Ele foi introduzido por Stefan Milton Bache no pacote magrittr, cujo nome é uma referência ao famoso quadro do pintor belga René Magritte La Trahison des images (Ceci n’est pas une pipe). Figura 6.1: Reprodução do quadro La Trahison des images (Ceci n’est pas une pipe). do pintor René Magritte. Para começar a utilizar o pipe, instale e carregue o pacote magrittr. install.packages(&quot;magrittr&quot;) library(magrittr) "],["6-1-o-operador-pipe.html", "6.1 O operador pipe", " 6.1 O operador pipe A ideia do operador %&gt;% (pipe) é bem simples: usar o valor resultante da expressão do lado esquerdo como primeiro argumento da função do lado direito. # As duas linhas abaixo são equivalentes. f(x, y) x %&gt;% f(y) Nos casos mais simples, o pipe parece não trazer grandes vantagens. Agora, veja como fica um caso com mais etapas. # Vamos calcular a raiz quadrada da soma dos valores de 1 a 4. Primeiro, sem o pipe. x &lt;- c(1, 2, 3, 4) sqrt(sum(x)) ## [1] 3.162278 # Agora com o pipe. x %&gt;% sum() %&gt;% sqrt() ## [1] 3.162278 O caminho que o código x %&gt;% sum %&gt;% sqrt seguiu foi enviar o objeto x como argumento da função sum() e, em seguida, enviar a saida da expressão sum(x) como argumento da função sqrt(). Observe que escrevemos o código na mesma ordem em que as operações são realizadas. A utilização de parênteses após o nome das funções não é necessário, mas recomendável. Se você ainda não está convencido com o poder do pipe, fica que vai ter bolo! No exemplo abaixo, vamos ilustrar um caso em que temos um grande número de funções aninhadas. Veja como a utilização do pipe transforma um código confuso e difícil de ser lido em algo simples e intuitivo. # Receita de bolo sem pipe. Tente entender o que é preciso fazer. esfrie( asse( coloque( bata( acrescente( recipiente( rep(&quot;farinha&quot;, 2), &quot;água&quot;, &quot;fermento&quot;, &quot;leite&quot;, &quot;óleo&quot; ), &quot;farinha&quot;, ate = &quot;macio&quot; ), duracao = &quot;3min&quot; ), lugar = &quot;forma&quot;, tipo = &quot;grande&quot;, untada = TRUE ), duracao = &quot;50min&quot; ), lugar = &quot;geladeira&quot;, duracao = &quot;20min&quot; ) # Veja como o código acima pode ser reescrito utilizando-se o pipe. Agora realmente se parece com uma receita de bolo. recipiente(rep(&quot;farinha&quot;, 2), &quot;água&quot;, &quot;fermento&quot;, &quot;leite&quot;, &quot;óleo&quot;) %&gt;% acrescente(&quot;farinha&quot;, ate = &quot;macio&quot;) %&gt;% bata(duracao = &quot;3min&quot;) %&gt;% coloque(lugar = &quot;forma&quot;, tipo = &quot;grande&quot;, untada = TRUE) %&gt;% asse(duracao = &quot;50min&quot;) %&gt;% esfrie(lugar = &quot;geladeira&quot;, duracao = &quot;20min&quot;) Às vezes, queremos que o resultado do lado esquerdo vá para outro argumento do lado direito que não o primeiro. Para isso, utilizamos um . como marcador. # Queremos que o dataset seja recebido pelo segundo argumento (data=) da função &quot;lm&quot;. airquality %&gt;% na.omit() %&gt;% lm(Ozone ~ Wind + Temp + Solar.R, data = .) %&gt;% summary() ## ## Call: ## lm(formula = Ozone ~ Wind + Temp + Solar.R, data = .) ## ## Residuals: ## Min 1Q Median 3Q Max ## -40.485 -14.219 -3.551 10.097 95.619 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -64.34208 23.05472 -2.791 0.00623 ** ## Wind -3.33359 0.65441 -5.094 1.52e-06 *** ## Temp 1.65209 0.25353 6.516 2.42e-09 *** ## Solar.R 0.05982 0.02319 2.580 0.01124 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 21.18 on 107 degrees of freedom ## Multiple R-squared: 0.6059, Adjusted R-squared: 0.5948 ## F-statistic: 54.83 on 3 and 107 DF, p-value: &lt; 2.2e-16 O pipe é a força da gravidade dentro do tidyverse. Veremos nos próximos capítulos como as funções de diferentes pacotes interagem perfeitamente graças a esse operador. "],["6-2-outros-operadores.html", "6.2 Outros operadores", " 6.2 Outros operadores O pacote {magrittr} possui outros operadores, que, embora sejam menos utilizados, também são úteis. São eles: Assignment operator %&lt;&gt;% Operador tee %T&gt;% Exposition operator %$% Imagine que queremos tirar a raiz quadrada de um vetor de números. x &lt;- c(1, 2, 3, 4, 5) x %&gt;% sqrt() ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 Se quisermos sobrescrever o objeto x com a raiz quadrada dos seus valores, basta utilizarmos o nosso bom e velho operador de atribuição &lt;-. x &lt;- x %&gt;% sqrt() Podemos, no entanto, utilizar o operador %&lt;&gt;% para reescrever o código acima de uma maneira mais compacta. x &lt;- c(1, 2, 3, 4, 5) x %&lt;&gt;% sqrt() Além de mandar o objeto x para o primeiro argumento da função sqrt(), assim como o %&gt;% faria, esse operador também salva o resultado da operação de volta no objeto x, o sobrescrevendo. Este operador pode ser usado sempre que desejamos fazer algo da forma objeto &lt;- objeto %&gt;% funcao_1() %&gt;% funcao_2() %&gt;% ... funcao_n() O operador %T&gt;% retorna o valor do comando anterior a ele, não o resultado do lado direito como o %&gt;% faz. O seguinte exemplo vai imprimir na tela os valores de 1 a 10. Se usássemos o pipe, o código retornaria a soma dos dez números. 1:10 %T&gt;% sum() %&gt;% cat() ## 1 2 3 4 5 6 7 8 9 10 Neste caso, o operador não parece fazer sentido e apenas deixa o código mais complicado, mas se desejamos usar funções como cat() ou plot() que não retornam nada, o operador se torna muito útil. # Vamos imprimir na tela os valores de 1 a 10 e depois soma-los. 1:10 %T&gt;% cat() %&gt;% sum() ## 1 2 3 4 5 6 7 8 9 10 ## [1] 55 O operador %$% pode ser utilizado para expor as colunas de um data frame para a função aplicada no lado direito. # Podemos chamar qualquer coluna da base diretamente. mtcars %$% mean(mpg) ## [1] 20.09062 Se não ficou claro o que esse operador está fazendo, imagine que ele transforma todas as colunas da base em objetos (assim como a nefasta função attach()), mas sem salvar nada no nosso environment. mtcars %$% mpg %&gt;% mean() %&gt;% sqrt() ## [1] 4.482257 Ele faz um papel equivalente ao operador $. mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 mtcars %$% mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 Para mais informações sobre o pipe e outras funções do pacote {magrittr}, visite a página Ceci n’est pas un pipe. "],["6-3-exercícios-10.html", "6.3 Exercícios", " 6.3 Exercícios 1. Reescreva a expressão abaixo utilizando o %&gt;%. round(mean(sum(1:10)/3), digits = 1) Dica: utilize a função magrittr::divide_by(). Veja o help da função para mais informações. 2. Reescreva o código abaixo utilizando o %&gt;%. x &lt;- rnorm(100) x.pos &lt;- x[x&gt;0] media &lt;- mean(x.pos) saida &lt;- round(media, 1) 3. Sem rodar, diga qual a saída do código abaixo. Consulte o help das funções caso precise. 2 %&gt;% add(2) %&gt;% c(6, NA) %&gt;% mean(na.rm = T) %&gt;% equals(5) 4. Leia o capítulo sobre pipes do R for data science. É curto e vale muito a pena. 5. Pegue algum script que você já tenha programado em R e o reescreva utilizando o operador pipe. Se você não tiver nenhum, não se preocupe. Utilizaremos bastante o pipe daqui pra frente. "],["7-manipulacao.html", "Capítulo 7 Manipulação", " Capítulo 7 Manipulação Esta seção trata do tema manipulação de dados. Trata-se de uma tarefa dolorosa e demorada, tomando muitas vezes a maior parte do tempo de uma análise de dados. Apesar de negligenciada pela Estatística, essa etapa é essencial para o sucesso da análise. The fact that data science exists as a field is a colossal failure of statistics. To me, what I do is what statistics is all about. It is gaining insight from data using modelling and visualization. Data munging and manipulation is hard and statistics has just said that’s not our domain. — Hadley Wickham Usualmente, o cientista de dados parte de uma base “crua” e a transforma até obter uma base de dados analítica, que, a menos de transformações simples, está preparada para gerar tabelas e gráficos e alimentar modelos. Figura 7.1: Estamos na etapa de arrumação do ciclo da Ciência de Dados. Um conceito importante para obtenção de uma base analítica é o data tidying, ou arrumação de dados. Uma base é considerada tidy se Cada linha da base representa uma observação. Cada coluna da base representa uma variável. A base de dados analítica é estruturada de tal forma que pode ser colocada diretamente em ambientes de modelagem estatística ou de visualização. Nem sempre uma base de dados analítica está no formato tidy, mas usualmente são necessários poucos passos para migrar de uma para outra. A filosofia tidy é a base do tidyverse. Os principais pacotes encarregados da tarefa de estruturar os dados são o dplyr e o tidyr. Eles serão o tema desse capítulo. Instale e carregue os pacotes utilizando: install.packages(c(&quot;dplyr&quot;, &quot;tidyr&quot;)) library(dplyr) library(tidyr) Mas antes de apresentar as principais funções do dplyr e do tidyr, precisamos falar sobre o conceito de tibbles. "],["7-1-tibbles.html", "7.1 Tibbles", " 7.1 Tibbles Uma tibble é um data frame com ajustes que as deixam mais amigáveis a nós cientistas de dados. Elas são parte do pacote {tibble}. Assim, para começar a usá-las, instale e carregue o pacote. install.packages(&quot;tibble&quot;) library(tibble) Há duas formas de criar uma tibble. A primeira é transformar um data frame em tibble utilizando a função as_tibble(). as_tibble(mtcars) ## # A tibble: 32 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Veja que, por padrão, apenas as dez primeiras linhas da base são apresentadas. Além disso, colunas que não couberem na largura da tela serão omitidas. Também são apresentadas a dimensão da tabela e as classes de cada coluna. Compare a diferença de impressão com relação a um data frame. mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Veja também que, ao contrário dos data frames, tibbles não utilizam nome nas linhas. A segunda forma de criar uma tibble é a partir de vetores individuais, utilizando a função tibble(). tibble( coluna1 = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), coluna2 = 1:4, coluna3 = coluna2 ^ 2, coluna4 = 0 ) ## # A tibble: 4 x 4 ## coluna1 coluna2 coluna3 coluna4 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 1 1 0 ## 2 b 2 4 0 ## 3 c 3 9 0 ## 4 d 4 16 0 Observamos pelo código acima que: podemos criar uma coluna a partir de uma função de colunas anteriores (a coluna3 é uma função da coluna2); se passarmos um vetor de tamanho 1 a uma das colunas, esse vetor será reciclado, igualando-se ao número de linha da tibble (o 0 na coluna4 é transformado em c(0, 0, 0, 0)). Uma outra diferença entre data frames e tibbles está no subsetting. Tibbles nunca fazem correspondência parcial. Tibbles retornam NULL e um aviso quando você tenta selecionar uma coluna que não existe. # O nome da coluna é disp, mas você pode acessá-la # apenas a procurando por &quot;dis&quot;, já que não existe # nenhuma outra coluna que começa com &quot;dis&quot;. mtcars$dis ## [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 275.8 ## [13] 275.8 275.8 472.0 460.0 440.0 78.7 75.7 71.1 120.1 318.0 304.0 350.0 ## [25] 400.0 79.0 120.3 95.1 351.0 145.0 301.0 121.0 # Em tibbles isso não funciona. mtcars_tibble &lt;- as_tibble(mtcars) mtcars_tibble$dis ## Warning: Unknown or uninitialised column: `dis`. ## NULL Além de nos possibilitar a criar tibbles, o pacote {tibble} possui algumas funções úteis para manipularmos esses objetos: add_row() e add_column(): para adicionar linhas e colunas a uma tibble; rowid_to_column(): cria uma coluna com um id numérico e sequencial para as linhas, começando de 1. mtcars %&gt;% rowid_to_column() %&gt;% head(10) ## rowid mpg cyl disp hp drat wt qsec vs am gear carb ## 1 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 has_rownames(): verifica se um data frame possui linhas nomeadas. remove_rownames(): remove o nome das linhas de um data frame. rownames_to_column(): transforma o nome das linhas em uma coluna. rownames_to_column(mtcars, var = &quot;modelo_do_carro&quot;) ## modelo_do_carro mpg cyl disp hp drat wt qsec vs am gear carb ## 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 11 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 12 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 13 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 14 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 15 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 16 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 17 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 18 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 19 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 20 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 21 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 22 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 23 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 24 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 25 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 26 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 27 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 28 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 29 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 30 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 31 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 32 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 column_to_rownames(): transforma uma coluna em nomes das linhas. Mais informações sobre tibbles podem ser encontradas neste tutorial do RStudio e neste caplítulo do R for Data Science. "],["7-2-dplyr.html", "7.2 O pacote dplyr", " 7.2 O pacote dplyr O dplyr é o pacote mais útil para realizar transformação de dados, aliando simplicidade e eficiência de uma forma elegante. Os scripts em R que fazem uso inteligente dos verbos dplyr e as facilidades do operador pipe tendem a ficar mais legíveis e organizados sem perder velocidade de execução. As principais funções do dplyr são: select() - seleciona colunas arrange() - ordena a base filter() - filtra linhas mutate() - cria/modifica colunas group_by() - agrupa a base summarise() - sumariza a base Todas essas funções seguem as mesmas características: O input é sempre uma tibble e o output é sempre um tibble. Colocamos a tibble no primeiro argumento e o que queremos fazer nos outros argumentos. A utilização é facilitada com o emprego do operador %&gt;%. As principais vantagens de se usar o dplyr em detrimento das funções do R base são: Manipular dados se torna uma tarefa muito mais simples. O código fica mais intuitivo de ser escrito e mais simples de ser lido. O pacote dplyr utiliza C e C++ por trás da maioria das funções, o que geralmente torna o código mais rápido. É possível trabalhar com diferentes fontes de dados, como bases relacionais (SQL) e data.table. Se você ainda não tiver o dplyr instalado, rode o código abaixo. install.packages(&quot;dplyr&quot;) library(dplyr) Neste capítulo, vamos trabalhar com uma base de filmes do IMDB. Essa base pode ser baixada clicando aqui. Assim, utilizaremos o objeto imdb para acessar os dados. imdb &lt;- readr::read_rds(&quot;imdb.rds&quot;) imdb ## # A tibble: 3,807 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Agora, vamos avaliar com mais detalhes as principais funções do pacote dplyr. 7.2.1 Selecionando colunas Para selecionar colunas, utilizamos a função select(). O primeiro argumento da função é a base de dados e os demais argumentos são os nomes das colunas que você gostaria de selecionar. Repare que você não precisa colocar o nome da coluna entre aspas. select(imdb, titulo) ## # A tibble: 3,807 x 1 ## titulo ## &lt;chr&gt; ## 1 Avatar ## 2 Pirates of the Caribbean: At World&#39;s End ## 3 The Dark Knight Rises ## 4 John Carter ## 5 Spider-Man 3 ## 6 Tangled ## 7 Avengers: Age of Ultron ## 8 Batman v Superman: Dawn of Justice ## 9 Superman Returns ## 10 Pirates of the Caribbean: Dead Man&#39;s Chest ## # … with 3,797 more rows Você também pode selecionar várias colunas. select(imdb, titulo, ano, orcamento) ## # A tibble: 3,807 x 3 ## titulo ano orcamento ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Avatar 2009 237000000 ## 2 Pirates of the Caribbean: At World&#39;s End 2007 300000000 ## 3 The Dark Knight Rises 2012 250000000 ## 4 John Carter 2012 263700000 ## 5 Spider-Man 3 2007 258000000 ## 6 Tangled 2010 260000000 ## 7 Avengers: Age of Ultron 2015 250000000 ## 8 Batman v Superman: Dawn of Justice 2016 250000000 ## 9 Superman Returns 2006 209000000 ## 10 Pirates of the Caribbean: Dead Man&#39;s Chest 2006 225000000 ## # … with 3,797 more rows O operador : é muito útil para selecionar colunas consecutivas. select(imdb, titulo:cor) ## # A tibble: 3,807 x 5 ## titulo ano diretor duracao cor ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Avatar 2009 James Cameron 178 Color ## 2 Pirates of the Caribbean: At World&#39;s En… 2007 Gore Verbinski 169 Color ## 3 The Dark Knight Rises 2012 Christopher Nol… 164 Color ## 4 John Carter 2012 Andrew Stanton 132 Color ## 5 Spider-Man 3 2007 Sam Raimi 156 Color ## 6 Tangled 2010 Nathan Greno 100 Color ## 7 Avengers: Age of Ultron 2015 Joss Whedon 141 Color ## 8 Batman v Superman: Dawn of Justice 2016 Zack Snyder 183 Color ## 9 Superman Returns 2006 Bryan Singer 169 Color ## 10 Pirates of the Caribbean: Dead Man&#39;s Ch… 2006 Gore Verbinski 151 Color ## # … with 3,797 more rows O dplyr possui o conjunto de funções auxiliares muito úteis para seleção de colunas. As principais são: starts_with(): para colunas que começam com um texto padrão ends_with(): para colunas que terminam com um texto padrão contains(): para colunas que contêm um texto padrão Selecionamos a seguir todas as colunas que começam com o texto “ator”. select(imdb, starts_with(&quot;ator&quot;)) ## # A tibble: 3,807 x 3 ## ator_1 ator_2 ator_3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CCH Pounder Joel David Moore Wes Studi ## 2 Johnny Depp Orlando Bloom Jack Davenport ## 3 Tom Hardy Christian Bale Joseph Gordon-Levitt ## 4 Daryl Sabara Samantha Morton Polly Walker ## 5 J.K. Simmons James Franco Kirsten Dunst ## 6 Brad Garrett Donna Murphy M.C. Gainey ## 7 Chris Hemsworth Robert Downey Jr. Scarlett Johansson ## 8 Henry Cavill Lauren Cohan Alan D. Purwin ## 9 Kevin Spacey Marlon Brando Frank Langella ## 10 Johnny Depp Orlando Bloom Jack Davenport ## # … with 3,797 more rows Para retirar colunas da base, base acrescentar um - antes da seleção. imdb %&gt;% select(-ano, - diretor) ## # A tibble: 3,807 x 13 ## titulo duracao cor generos pais classificacao orcamento receita nota_imdb ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Avata… 178 Color Action… USA A partir de … 237000000 7.61e8 7.9 ## 2 Pirat… 169 Color Action… USA A partir de … 300000000 3.09e8 7.1 ## 3 The D… 164 Color Action… USA A partir de … 250000000 4.48e8 8.5 ## 4 John … 132 Color Action… USA A partir de … 263700000 7.31e7 6.6 ## 5 Spide… 156 Color Action… USA A partir de … 258000000 3.37e8 6.2 ## 6 Tangl… 100 Color Advent… USA Livre 260000000 2.01e8 7.8 ## 7 Aveng… 141 Color Action… USA A partir de … 250000000 4.59e8 7.5 ## 8 Batma… 183 Color Action… USA A partir de … 250000000 3.30e8 6.9 ## 9 Super… 169 Color Action… USA A partir de … 209000000 2.00e8 6.1 ## 10 Pirat… 151 Color Action… USA A partir de … 225000000 4.23e8 7.3 ## # … with 3,797 more rows, and 4 more variables: likes_facebook &lt;int&gt;, ## # ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; imdb %&gt;% select(-starts_with(&quot;ator&quot;)) ## # A tibble: 3,807 x 12 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 3 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt; Exercícios Utilize a base imdb nos exercícios a seguir. 1. Teste aplicar a função glimpse() do pacote {dplyr} à base imdb. O que ela faz? 2. Crie uma tabela com apenas as colunas titulo, diretor, e orcamento. Salve em um objeto chamado imdb_simples. 3. Selecione apenas as colunas ator_1, ator_2 e ator_3 usando o ajudante contains(). 4. Usando a função select() (e seus ajudantes), escreva códigos que retornem a base IMDB sem as colunas ator_1, ator_2 e ator_3. Escreva todas as soluções diferentes que você conseguir pensar. 7.2.2 Ordenando a base Para ordenar linhas, utilizamos a função arrange(). O primeiro argumento é a base de dados. Os demais argumentos são as colunas pelas quais queremos ordenar as linhas. No exemplo a seguir, ordenamos as linhas da base por ordem crescente de orçamento. arrange(imdb, orcamento) ## # A tibble: 3,807 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Tarna… 2003 Jonath… 88 Color Biogra… USA Outros 218 ## 2 My Da… 2004 Jon Gu… 90 Color Docume… USA Livre 1100 ## 3 A Pla… 2013 Benjam… 76 Color Drama|… USA Outros 1400 ## 4 The M… 2005 Anthon… 84 Color Crime|… USA A partir de … 3250 ## 5 Prime… 2004 Shane … 77 Color Drama|… USA A partir de … 7000 ## 6 El Ma… 1992 Robert… 81 Color Action… USA A partir de … 7000 ## 7 Newly… 2011 Edward… 95 Color Comedy… USA Outros 9000 ## 8 Pink … 1972 John W… 108 Color Comedy… USA A partir de … 10000 ## 9 The T… 2007 Jane C… 7 Color Romanc… USA Outros 13000 ## 10 Paran… 2007 Oren P… 84 Color Horror USA A partir de … 15000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Também podemos ordenar de forma decrescente usando a função desc(). arrange(imdb, desc(orcamento)) ## # A tibble: 3,807 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 2 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 3 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 4 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Pirat… 2011 Rob Ma… 136 Color Action… USA A partir de … 250000000 ## 10 Capta… 2016 Anthon… 147 Color Action… USA A partir de … 250000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; E claro, ordenar segundo duas ou mais colunas. arrange(imdb, desc(ano), desc(orcamento)) ## # A tibble: 3,807 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 2 Capta… 2016 Anthon… 147 Color Action… USA A partir de … 250000000 ## 3 Star … 2016 Justin… 122 Color Action… USA A partir de … 185000000 ## 4 The L… 2016 David … 110 Color Action… USA A partir de … 180000000 ## 5 The L… 2016 David … 110 Color Action… USA A partir de … 180000000 ## 6 X-Men… 2016 Bryan … 144 Color Action… USA A partir de … 178000000 ## 7 Suici… 2016 David … 123 Color Action… USA A partir de … 175000000 ## 8 Alice… 2016 James … 113 Color Advent… USA Livre 170000000 ## 9 Indep… 2016 Roland… 120 Color Action… USA A partir de … 165000000 ## 10 Warcr… 2016 Duncan… 123 Color Action… USA A partir de … 160000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Exercícios Utilize a base imdb nos exercícios a seguir. 1. Ordene os filmes em ordem crescente de ano e decrescente de receita e salve em um objeto chamado filmes_ordenados. 2. Selecione apenas as colunas titulo e orcamento e então ordene de forma decrescente pelo orcamento. 7.2.3 O pipe em ação Na grande maioria dos casos, vamos aplicar mais de uma função de manipulação em uma base para obtermos a tabela que desejamos. Poderíamos, por exemplo, querer uma tabela apenas com o título e ano dos filmes, ordenada de forma crescente de lançamento. Para fazer isso, poderíamos aninhar as funções arrange(select(imdb, titulo, ano), ano) ## # A tibble: 3,807 x 2 ## titulo ano ## &lt;chr&gt; &lt;int&gt; ## 1 Intolerance: Love&#39;s Struggle Throughout the Ages 1916 ## 2 Over the Hill to the Poorhouse 1920 ## 3 The Big Parade 1925 ## 4 The Broadway Melody 1929 ## 5 Hell&#39;s Angels 1930 ## 6 A Farewell to Arms 1932 ## 7 42nd Street 1933 ## 8 She Done Him Wrong 1933 ## 9 It Happened One Night 1934 ## 10 Top Hat 1935 ## # … with 3,797 more rows ou criar um objeto intermediário tab_titulo_ano &lt;- select(imdb, titulo, ano) arrange(tab_titulo_ano, ano) ## # A tibble: 3,807 x 2 ## titulo ano ## &lt;chr&gt; &lt;int&gt; ## 1 Intolerance: Love&#39;s Struggle Throughout the Ages 1916 ## 2 Over the Hill to the Poorhouse 1920 ## 3 The Big Parade 1925 ## 4 The Broadway Melody 1929 ## 5 Hell&#39;s Angels 1930 ## 6 A Farewell to Arms 1932 ## 7 42nd Street 1933 ## 8 She Done Him Wrong 1933 ## 9 It Happened One Night 1934 ## 10 Top Hat 1935 ## # … with 3,797 more rows Os dois códigos funcionam e levam ao mesmo resultado, mas não são muito boas. A primeira alternativa é ruim de escrever, já que precisamos escrever primeiro a função que roda por último, e de ler, pois é difícil identificar qual argumento pertence a qual função. A segunda alternativa é ruim pois exige a criação de objetos auxiliares. Se quiséssimos aplicar 10 operações na base, precisaríamos criar 9 objetos intermediários. A solução para aplicar diversas operações de manipulação em uma base de dados é aplicar o operador pipe: %&gt;%. imdb %&gt;% select(titulo, ano) %&gt;% arrange(ano) ## # A tibble: 3,807 x 2 ## titulo ano ## &lt;chr&gt; &lt;int&gt; ## 1 Intolerance: Love&#39;s Struggle Throughout the Ages 1916 ## 2 Over the Hill to the Poorhouse 1920 ## 3 The Big Parade 1925 ## 4 The Broadway Melody 1929 ## 5 Hell&#39;s Angels 1930 ## 6 A Farewell to Arms 1932 ## 7 42nd Street 1933 ## 8 She Done Him Wrong 1933 ## 9 It Happened One Night 1934 ## 10 Top Hat 1935 ## # … with 3,797 more rows O que está sendo feito no código com pipe? Da primeira para a segunda linha, estamos aplicando a função select() à base imdb. Da segunda para a terceira, estamos aplicando a função arrange() à base resultante da função select(). O resultado desse código é identico às tentativas sem pipe, com a vantagem de termos escrito o código na ordem em que as funções são aplicadas, de termos um código muito mais legível e de não precisarmos utilizar objetos intermediários. 7.2.4 Filtrando linhas Para filtrar valores de uma coluna da base, utilizamos a função filter(). imdb %&gt;% filter(nota_imdb &gt; 9) ## # A tibble: 3 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 The S… 1994 Frank … 142 Color Crime|… USA A partir de … 25000000 ## 2 The G… 1972 Franci… 175 Color Crime|… USA A partir de … 6000000 ## 3 Kickb… 2016 John S… 90 &lt;NA&gt; Action USA Outros 17000000 ## # … with 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Podemos selecionar apenas as colunas título e nota para visualizarmos as notas: imdb %&gt;% filter(nota_imdb &gt; 9) %&gt;% select(titulo, nota_imdb) ## # A tibble: 3 x 2 ## titulo nota_imdb ## &lt;chr&gt; &lt;dbl&gt; ## 1 The Shawshank Redemption 9.3 ## 2 The Godfather 9.2 ## 3 Kickboxer: Vengeance 9.1 Podemos estender o filtro para duas ou mais colunas. Para isso, separamos cada operação por uma vírgula. imdb %&gt;% filter(ano &gt; 2010, nota_imdb &gt; 8.5) ## # A tibble: 5 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Inter… 2014 Christ… 169 Color Advent… USA A partir de … 165000000 ## 2 Runni… 2015 Mike M… 88 Color Family USA Outros 5000000 ## 3 A Beg… 2016 Mitche… 87 Color Comedy… USA Outros NA ## 4 Kickb… 2016 John S… 90 &lt;NA&gt; Action USA Outros 17000000 ## 5 Butte… 2014 Cary B… 78 Color Docume… USA Outros 180000 ## # … with 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Também podemos fazer operações com as colunas da base dentro da função filter. O código abaixo devolve uma tabela apenas com os filmes que lucraram. imdb %&gt;% filter(receita - orcamento &gt; 0) ## # A tibble: 1,761 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 5 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 6 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 7 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## 8 Man o… 2013 Zack S… 143 Color Action… USA A partir de … 225000000 ## 9 The A… 2012 Joss W… 173 Color Action… USA A partir de … 220000000 ## 10 The A… 2012 Marc W… 153 Color Action… USA A partir de … 230000000 ## # … with 1,751 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Naturalmente, podemos filtrar colunas categóricas. O exemplo abaixo retorna uma tabela apenas com os filmes com a Angelina Jolie Pitt ou o Brad Pitt no papel principal. imdb %&gt;% filter(ator_1 %in% c(&#39;Angelina Jolie Pitt&#39;, &quot;Brad Pitt&quot;)) ## # A tibble: 29 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Malef… 2014 Robert… 97 Color Action… USA Livre 180000000 ## 2 The C… 2008 David … 166 Color Drama|… USA A partir de … 150000000 ## 3 Kung … 2011 Jennif… 90 Color Action… USA Livre 150000000 ## 4 Troy 2004 Wolfga… 196 Color Advent… USA A partir de … 175000000 ## 5 Kung … 2008 Mark O… 92 Color Action… USA Livre 130000000 ## 6 Salt 2010 Philli… 101 Color Action… USA A partir de … 110000000 ## 7 Ocean… 2004 Steven… 125 Color Crime|… USA A partir de … 110000000 ## 8 Mr. &amp;… 2005 Doug L… 126 Color Action… USA A partir de … 120000000 ## 9 Lara … 2001 Simon … 100 Color Action… USA A partir de … 115000000 ## 10 Ocean… 2001 Steven… 116 Color Crime|… USA A partir de … 85000000 ## # … with 19 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Para filtrar textos sem correspondência exata, podemos utilizar a função auxiliar str_detect() do pacote {stringr}. Ela serve para verificar se cada string de um vetor contém um determinado padrão de texto. library(stringr) str_detect( string = c(&quot;a&quot;, &quot;aa&quot;,&quot;abc&quot;, &quot;bc&quot;, &quot;A&quot;, NA), pattern = &quot;a&quot; ) ## [1] TRUE TRUE TRUE FALSE FALSE NA Podemos utilizá-la para filtrar apenas os filmes que contêm o gênero ação. # A coluna gêneros apresenta todos os gêneros dos filmes concatenados imdb$generos[1:6] ## [1] &quot;Action|Adventure|Fantasy|Sci-Fi&quot; ## [2] &quot;Action|Adventure|Fantasy&quot; ## [3] &quot;Action|Thriller&quot; ## [4] &quot;Action|Adventure|Sci-Fi&quot; ## [5] &quot;Action|Adventure|Romance&quot; ## [6] &quot;Adventure|Animation|Comedy|Family|Fantasy|Musical|Romance&quot; # Podemos detectar se o gênero Action aparece na string str_detect( string = imdb$generos[1:6], pattern = &quot;Action&quot; ) ## [1] TRUE TRUE TRUE TRUE TRUE FALSE # Aplicamos essa lógica dentro da função filter, para a coluna completa imdb %&gt;% filter(str_detect(generos, &quot;Action&quot;)) ## # A tibble: 861 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 7 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 8 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 9 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## 10 The L… 2013 Gore V… 150 Color Action… USA A partir de … 215000000 ## # … with 851 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Exercícios Utilize a base imdb nos exercícios a seguir. 1. Crie um objeto chamado filmes_pb apenas com filmes preto e branco. 2. Crie um objeto chamado curtos_legais com filmes de 90 minutos ou menos de duração e nota no imdb maior do que 8.5. 3. Retorne tabelas (tibbles) apenas com: a. filmes coloridos anteriores a 1950; b. filmes do “Woody Allen” ou do “Wes Anderson”; c. filmes do “Steven Spielberg” ordenados de forma decrescente por ano, mostrando apenas as colunas titulo e ano; d. filmes que tenham “Action” ou “Comedy” entre os seus gêneros; e. filmes que tenham “Action” e “Comedy” entre os seus gêneros e tenha nota_imdb maior que 8; f. filmes que não possuem informação tanto de receita quanto de orçamento (isto é, possuem NA em ambas as colunas). 7.2.5 Modificando e criando novas colunas Para modificar uma coluna existente ou criar uma nova coluna, utilizamos a função mutate(). O código abaixo divide os valores da coluna duração por 60, mudando a unidade de medida dessa variável de minutos para horas. imdb %&gt;% mutate(duracao = duracao/60) ## # A tibble: 3,807 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 2.97 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 2.82 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 2.73 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 2.2 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 2.6 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 1.67 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 2.35 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 3.05 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 2.82 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 2.52 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Também poderíamos ter criado essa variável em uma nova coluna. Repare que a nova coluna duracao_horas é colocada no final da tabela. imdb %&gt;% mutate(duracao_horas = duracao/60) ## # A tibble: 3,807 x 16 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 7 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;, ## # duracao_horas &lt;dbl&gt; Podemos fazer qualquer operação com uma ou mais colunas. A única regra é que o resultado da operação retorne um vetor com comprimento igual ao número de linhas da base (ou com comprimento 1 para distribuir um mesmo valor em todas as linhas). Você também pode criar/modificar quantas colunas quiser dentro de um mesmo mutate. imdb %&gt;% mutate(lucro = receita - orcamento, pais = &quot;Estados Unidos&quot;) %&gt;% select(titulo, lucro, pais) ## # A tibble: 3,807 x 3 ## titulo lucro pais ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Avatar 523505847 Estados Unidos ## 2 Pirates of the Caribbean: At World&#39;s End 9404152 Estados Unidos ## 3 The Dark Knight Rises 198130642 Estados Unidos ## 4 John Carter -190641321 Estados Unidos ## 5 Spider-Man 3 78530303 Estados Unidos ## 6 Tangled -59192738 Estados Unidos ## 7 Avengers: Age of Ultron 208991599 Estados Unidos ## 8 Batman v Superman: Dawn of Justice 80249062 Estados Unidos ## 9 Superman Returns -8930592 Estados Unidos ## 10 Pirates of the Caribbean: Dead Man&#39;s Chest 198032628 Estados Unidos ## # … with 3,797 more rows Exercícios Utilize a base imdb nos exercícios a seguir. 1. Crie uma coluna chamada prejuizo (orcamento - receita) e salve a nova tabela em um objeto chamado imdb_prejuizo. Em seguida, filtre apenas os filmes que deram prejuízo e ordene a tabela por ordem crescente de prejuízo. 2. Fazendo apenas uma chamada da função mutate(), crie as seguintes colunas novas na base imdb: a. lucro = receita - orcamento b. lucro_medio c. lucro_relativo = (lucro - lucro_medio)/lucro_medio d. houve_lucro = ifelse(lucro &gt; 0, \"sim\", \"não\") 3. Crie uma nova coluna que classifique o filme em \"recente\" (posterior a 2000) e \"antigo\" (de 2000 para trás). 7.2.6 Summarisando a base Sumarização é a técnica de se resumir um conjunto de dados utilizando alguma métrica de interesse. A média, a mediana, a variância, a frequência, a proporção, por exemplo, são tipos de sumarização que trazem diferentes informações sobre uma variável. Para sumarizar uma coluna da base, utilizamos a função summarize(). O código abaixo resume a coluna orçamento pela sua média. imdb %&gt;% summarize(media_orcamento = mean(orcamento, na.rm = TRUE)) ## # A tibble: 1 x 1 ## media_orcamento ## &lt;dbl&gt; ## 1 35755986. Repare que a saída da função continua sendo uma tibble. Podemos calcular diversas sumarizações diferentes em um mesmo summarize. Cada sumarização será uma coluna da nova base. imdb %&gt;% summarise( media_orcamento = mean(orcamento, na.rm = TRUE), mediana_orcamento = median(orcamento, na.rm = TRUE), variancia_orcamento = var(orcamento, na.rm = TRUE) ) ## # A tibble: 1 x 3 ## media_orcamento mediana_orcamento variancia_orcamento ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 35755986. 20000000 1822337181441743. E também sumarizar diversas colunas. imdb %&gt;% summarize( media_orcamento = mean(orcamento, na.rm = TRUE), media_receita = mean(receita, na.rm = TRUE), media_lucro = mean(receita - orcamento, na.rm = TRUE) ) ## # A tibble: 1 x 3 ## media_orcamento media_receita media_lucro ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 35755986. 55214607. 17258230. Muitas vezes queremos sumarizar uma coluna agrupada pelas categorias de uma segunda coluna. Para isso, além do summarize, utilizamos também a função group_by(). O código a seguir calcula a receita média dos filmes para cada categoria da coluna “cor”. imdb %&gt;% group_by(cor) %&gt;% summarise(receita_media = mean(receita, na.rm = TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 2 ## cor receita_media ## &lt;chr&gt; &lt;dbl&gt; ## 1 Black and White 36938737. ## 2 Color 55765813. ## 3 &lt;NA&gt; 80014842 A única alteração que a função group_by() faz na base é a marcação de que a base está agrupada. imdb %&gt;% group_by(cor) ## # A tibble: 3,807 x 15 ## # Groups: cor [3] ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; Exercícios Utilize a base imdb nos exercícios a seguir. 1. Calcule a duração média e mediana dos filmes da base. 2. Calcule o lucro médio dos filmes com duração menor que 60 minutos. 3. Apresente na mesma tabela o lucro médio dos filmes com duracao menor que 60 minutos e o lucro médio dos filmes com duracao maior ou igual a 60 minutos. 4. Retorne tabelas (tibbles) apenas com: a. a nota IMDB média dos filmes por tipo de classificacao; b. a receita média e mediana dos filmes por ano; c. apenas o nome dos diretores com mais de 10 filmes. 7.2.7 Juntando duas bases Podemos juntar duas tabelas a partir de uma (coluna) chave utilizando a função left_join(). Como exempo, vamos inicialmente calcular o lucro médio dos filmes de cada diretor e salvar no objeto tab_lucro_diretor. tab_lucro_diretor &lt;- imdb %&gt;% group_by(diretor) %&gt;% summarise(lucro_medio = mean(receita - orcamento, na.rm = TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) tab_lucro_diretor ## # A tibble: 1,813 x 2 ## diretor lucro_medio ## &lt;chr&gt; &lt;dbl&gt; ## 1 A. Raven Cruz NaN ## 2 Aaron Hann NaN ## 3 Aaron Schneider 1676553 ## 4 Aaron Seltzer 28546578 ## 5 Abel Ferrara -11272676 ## 6 Adam Carolla -1394057 ## 7 Adam Goldberg -1647420 ## 8 Adam Green NaN ## 9 Adam Jay Epstein NaN ## 10 Adam Marcus 13435068 ## # … with 1,803 more rows E se quisermos colocar essa informação na base original? Basta usar a função left_join() utilizando a coluna diretor como chave. Observe que a coluna lucro_medio aparece agora no fim da tabela. imdb_com_lucro_medio &lt;- left_join(imdb, tab_lucro_diretor, by = &quot;diretor&quot;) imdb_com_lucro_medio ## # A tibble: 3,807 x 16 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 7 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;, ## # lucro_medio &lt;dbl&gt; Na tabela imdb_com_lucro_medio, como na tabela imdb, cada linha continua a representar um filme diferente, mas agora temos também a informação do lucro médio do diretor de cada filme. A primeira linha, por exemplo, traz as informações do filme Avatar. O valor do lucro_medio nessa linha representa o lucro médio de todos os filmes do James Cameron, que é o diretor de Avatar. Com essa informação, podemos calcular o quanto o lucro do Avatar se afasta do lucro médio do James Cameron. imdb_com_lucro_medio %&gt;% mutate( lucro = receita - orcamento, lucro_relativo = (lucro - lucro_medio)/lucro_medio, lucro_relativo = scales::percent(lucro_relativo) ) %&gt;% select(titulo, diretor, lucro, lucro_medio, lucro_relativo) ## # A tibble: 3,807 x 5 ## titulo diretor lucro lucro_medio lucro_relativo ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Avatar James Cameron 5.24e8 194620985 168.98736% ## 2 Pirates of the Caribbean: … Gore Verbins… 9.40e6 36942999. -74.54416% ## 3 The Dark Knight Rises Christopher … 1.98e8 101028447 96.11372% ## 4 John Carter Andrew Stant… -1.91e8 46668146 -508.50417% ## 5 Spider-Man 3 Sam Raimi 7.85e7 63300090. 24.06033% ## 6 Tangled Nathan Greno -5.92e7 -59192738 0.00000% ## 7 Avengers: Age of Ultron Joss Whedon 2.09e8 250221657 -16.47741% ## 8 Batman v Superman: Dawn of… Zack Snyder 8.02e7 33149106. 142.08514% ## 9 Superman Returns Bryan Singer -8.93e6 -2887024. 209.33560% ## 10 Pirates of the Caribbean: … Gore Verbins… 1.98e8 36942999. 436.04913% ## # … with 3,797 more rows Observamos então que o Avatar obteve um lucro aproximadamente 169% maior que a média dos filmes do James Cameron. Além da função left_join(), também são muito utilizadas as funções right_join() e full_join(). right_join(): retorna todas as linhas da base y e todas as colunas das bases x e y. Linhas de y sem correspondentes em x receberão NA na nova base. full_join(): retorna todas as linhas e colunas de xe y. Valores sem correspondência entre as bases receberão NA na nova base. A figura a seguir esquematiza as operações dessas funções: Exercícios 1. Utilize a base imdb para resolver os itens a seguir. a. Salve em um novo objeto uma tabela com a nota média dos filmes de cada diretor. Essa tabela deve conter duas colunas (diretor e nota_imdb_media) e cada linha deve ser um diretor diferente. b. Use o left_join() para trazer a coluna nota_imdb_media da tabela do item anterior para a tabela imdb original. "],["7-3-tidyr.html", "7.3 O pacote tidyr", " 7.3 O pacote tidyr O pacote tidyr dispõe de funções úteis para deixar os seus dados no formato que você precisa para a análise. Na maioria das vezes, utilizamos para deixá-los tidy. Outras, precisamos “bagunçá-los” um pouco para poder aplicar alguma função específica. As principais funções deste pacote são a gather() e a spread() 7.3.1 gather() A função gather() “empilha” o banco de dados. Ela é utilizada principalmente quando as colunas da base não representam nomes de variáveis, mas sim seus valores. library(tidyr) imdb &lt;- readr::read_rds(&quot;assets/data/imdb.rds&quot;) imdb_gather &lt;- imdb %&gt;% mutate(id = 1:n()) %&gt;% gather( key = &quot;importancia_ator&quot;, value = &quot;nome_ator&quot;, ator_1, ator_2, ator_3 ) %&gt;% select(nome_ator, importancia_ator, everything()) imdb_gather ## # A tibble: 11,421 x 15 ## nome_ator importancia_ator titulo ano diretor duracao cor generos pais ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CCH Poun… ator_1 Avata… 2009 James … 178 Color Action… USA ## 2 Johnny D… ator_1 Pirat… 2007 Gore V… 169 Color Action… USA ## 3 Tom Hardy ator_1 The D… 2012 Christ… 164 Color Action… USA ## 4 Daryl Sa… ator_1 John … 2012 Andrew… 132 Color Action… USA ## 5 J.K. Sim… ator_1 Spide… 2007 Sam Ra… 156 Color Action… USA ## 6 Brad Gar… ator_1 Tangl… 2010 Nathan… 100 Color Advent… USA ## 7 Chris He… ator_1 Aveng… 2015 Joss W… 141 Color Action… USA ## 8 Henry Ca… ator_1 Batma… 2016 Zack S… 183 Color Action… USA ## 9 Kevin Sp… ator_1 Super… 2006 Bryan … 169 Color Action… USA ## 10 Johnny D… ator_1 Pirat… 2006 Gore V… 151 Color Action… USA ## # … with 11,411 more rows, and 6 more variables: classificacao &lt;chr&gt;, ## # orcamento &lt;int&gt;, receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, likes_facebook &lt;int&gt;, ## # id &lt;int&gt; 7.3.2 spread() A função spread() é essencialmente o inverso da gather(). Ela espalha uma variável nas colunas. imdb_spread &lt;- imdb_gather %&gt;% spread( key = importancia_ator, value = nome_ator ) imdb_spread ## # A tibble: 3,807 x 16 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 7 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, id &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; 7.3.3 Outras funções do tidyr A função unite() junta duas ou mais colunas usando algum separador (_, por exemplo). A função separate() faz o inverso de unite(): transforma uma coluna em várias usando um separador. imdb %&gt;% unite( col = &quot;titulo_diretor&quot;, titulo, diretor, sep = &quot; - &quot; ) ## # A tibble: 3,807 x 14 ## titulo_diretor ano duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Avatar - Jam… 2009 178 Color Action… USA A partir de … 237000000 ## 2 Pirates of th… 2007 169 Color Action… USA A partir de … 300000000 ## 3 The Dark Knig… 2012 164 Color Action… USA A partir de … 250000000 ## 4 John Carter … 2012 132 Color Action… USA A partir de … 263700000 ## 5 Spider-Man 3 … 2007 156 Color Action… USA A partir de … 258000000 ## 6 Tangled - Na… 2010 100 Color Advent… USA Livre 260000000 ## 7 Avengers: Age… 2015 141 Color Action… USA A partir de … 250000000 ## 8 Batman v Supe… 2016 183 Color Action… USA A partir de … 250000000 ## 9 Superman Retu… 2006 169 Color Action… USA A partir de … 209000000 ## 10 Pirates of th… 2006 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; imdb %&gt;% separate( col = generos, into = c(&quot;genero_1&quot;, &quot;genero_2&quot;, &quot;genero_3&quot;), sep = &quot;\\\\|&quot;, extra = &quot;drop&quot; ) ## # A tibble: 3,807 x 17 ## titulo ano diretor duracao cor genero_1 genero_2 genero_3 pais ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Avata… 2009 James … 178 Color Action Adventu… Fantasy USA ## 2 Pirat… 2007 Gore V… 169 Color Action Adventu… Fantasy USA ## 3 The D… 2012 Christ… 164 Color Action Thriller &lt;NA&gt; USA ## 4 John … 2012 Andrew… 132 Color Action Adventu… Sci-Fi USA ## 5 Spide… 2007 Sam Ra… 156 Color Action Adventu… Romance USA ## 6 Tangl… 2010 Nathan… 100 Color Adventu… Animati… Comedy USA ## 7 Aveng… 2015 Joss W… 141 Color Action Adventu… Sci-Fi USA ## 8 Batma… 2016 Zack S… 183 Color Action Adventu… Sci-Fi USA ## 9 Super… 2006 Bryan … 169 Color Action Adventu… Sci-Fi USA ## 10 Pirat… 2006 Gore V… 151 Color Action Adventu… Fantasy USA ## # … with 3,797 more rows, and 8 more variables: classificacao &lt;chr&gt;, ## # orcamento &lt;int&gt;, receita &lt;int&gt;, nota_imdb &lt;dbl&gt;, likes_facebook &lt;int&gt;, ## # ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; "],["8-graficos.html", "Capítulo 8 Gráficos", " Capítulo 8 Gráficos Agora que já temos em mãos as ferramentas para importar, arrumar e transformar os nossos dados, é hora de começarmos a extrair informações deles. Seguindo o nosso bom e velho ciclo da ciência de dados, o próximo passo é a construção de visualizações. A visualização dos dados é uma etapa importantíssima da análise estatística, pois é a partir dela que criamos a intuição necessária para escolher o teste ou modelo mais adequado para o nosso problema. Visualizações podem ser uma simples medida resumo (frequência, média, variância, mínimo, máximo, …), um conjunto dessas medidas organizadas em uma tabela ou a representação (de uma parte) dos dados em um gráfico. Nesse tópico, focaremos na construção de gráficos, uma tarefa que, apesar de nem sempre ser conceitualmente ou tecnicamente trivial, é muito facilitada pelas ferramentas disponíveis no R. Mas, antes de mais nada, o que é um gráfico estatístico? "],["8-1-o-pacote-ggplot2.html", "8.1 O pacote ggplot2", " 8.1 O pacote ggplot2 A construção de gráficos no R foi revolucionada com a criação do pacote ggplot2, fruto da tese de doutorado de Hadley Wickham. Essa revolução teve base na filosofia adotada por Hadley ao definir o que deveria ser um gráfico estatístico. Mas será que podemos definir formalmente o que é um gráfico estatístico? Graças ao estatístico norte-americano Leland Wilkinson, a resposta é sim. Em 2005, Leland publicou o livro The Grammar of graphics, uma fonte de princípios fundamentais para a construção de gráficos estatísticos. No livro, ele defende que um gráfico é o mapeamento dos dados a partir de atributos estéticos (posição, cor, forma, tamanho) de objetos geométricos (pontos, linhas, barras, caixas). A partir dessa definição, Hadley escreveu A Layered Grammar of Graphics, sugerindo que os principais aspectos de um gráfico (dados, sistema de coordenadas, rótulos e anotações) podiam ser divididos em camadas, construídas uma a uma na elaboração do gráfico. Essa é a essência do ggplot2. Além de uma filosofia bem fundamentada, o ggplot2 ainda traz outras vantagens em relação aos gráficos do r base: gráficos naturalmente mais bonitos; muito mais fácil deixar o gráfico do jeito que você quer; a estrutura padronizada das funções deixa o aprendizado muito mais intuitivo; e é possível criar uma imensa gama de gráficos com poucas linhas de código. Para discutir os principais aspectos da construção de gráficos com o ggplot2, vamos continuar utilizando a base de filmes do IMDB apresentada na seção de manipulação. Você pode baixá-la clicando aqui. Na próxima seção, vamos conhecer as principais funções do ggplot2 e começar a construir nossos primeiros gráficos. Não se esqueça de instalar e carregar o pacote antes de rodar os exemplos. install.packages(&quot;ggplot2&quot;) library(ggplot2) 8.1.1 As camadas de um gráfico No ggplot2, os gráficos são construídos camada por camada, sendo a primeira delas dada pela função ggplot() (repare que não tem o “2”). Essa função recebe um data frame e cria a camada base do gráfico. Se rodarmos apenas a função ggplot(), obteremos um painel em branco. imdb &lt;- readr::read_rds(&quot;assets/data/imdb.rds&quot;) ggplot(data = imdb) Apesar de termos passados os dados para a função, precisamos especificar como as observações serão mapeadas nos aspectos visuais do gráfico e quais formas geométricas serão utilizadas para isso. Cada camada do gráfico representará um tipo de mapeamento ou personalização. O código abaixo constrói um gráfico de dispersão entre as variáveis orçamento e receita. ggplot(imdb) + geom_point(aes(x = orcamento, y = receita)) ## Warning: Removed 733 rows containing missing values (geom_point). Observe que: como vimos, a primeira camada é dada pela função ggplot() e recebe um data frame; a segunda camada é dada pela função geom_point(), especificando a forma geométrica utilizada no mapeamento das observações; as camadas são unidas com um +; o mapeamento na função geom_point() recebe a função aes(), responsável por descrever como as variáveis serão mapeadas nos aspectos visuais da forma geométrica escolhida, no caso, pontos. A combinação da função ggplot() e de uma ou mais funções geom_() definirá o tipo de gráfico gerado. Atenção! As camadas dos gráficos são empilhadas utilizando-se o sinal +. Como a estrutura é muito parecida com uma pipe line, é comum trocarmos o + por um %&gt;% no meio do código, resultando em erro. Podemos acrescentar uma terceira camada ao gráfico, gerando a reta y = x para visualizarmos os filmes não se pagaram. ggplot(imdb) + geom_point(mapping = aes(x = orcamento, y = receita)) + geom_abline(intercept = 0, slope = 1, color = &quot;red&quot;) ## Warning: Removed 733 rows containing missing values (geom_point). Assim, os pontos abaixo da reta representam os filmes com orçamento maior que a receita, isto é, aqueles que deram prejuízo. Em vez de utilizarmos a reta y = x, podemos pintar os pontos que deram lucro e prejuízo de cores diferentes. library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union imdb %&gt;% mutate( lucro = receita - orcamento, lucro = ifelse(lucro &lt;= 0, &quot;Não&quot;, &quot;Sim&quot;) ) %&gt;% filter(!is.na(lucro)) %&gt;% ggplot() + geom_point(mapping = aes(x = orcamento, y = receita, color = lucro)) Aqui temos dois pontos importantes: Unimos uma primeira parte de manipulação, utilizando as funções filter() e mutate(), com o código do gráfico. Essa etapa inicial de transformação da base é muito comum na construção de gráficos. A cor dos pontos foi alterada por meio do atributo color=, dentro da função aes(). Também podemos adicionar uma camada especificando os textos que representam cada atributo. Para isso, usamos a função labs(). imdb %&gt;% mutate( lucro = receita - orcamento, lucro = ifelse(lucro &lt;= 0, &quot;Não&quot;, &quot;Sim&quot;) ) %&gt;% filter(!is.na(lucro)) %&gt;% ggplot() + geom_point(mapping = aes(x = orcamento, y = receita, color = lucro)) + labs(x = &quot;Orçamento&quot;, y = &quot;Arrecadação&quot;, color = &quot;Houve lucro?&quot;) No ggplot, nós modificamos um gráfico alterando e acrescentando camadas. Agora que você já sabe como essa estrutura funciona, vamos estudar com mais atenção para que serve a função aes(). 8.1.2 Atributos estéticos O papel da função aes() (de aesthetics, estética em inglês) é indicar a relação entre os dados e cada aspecto visual do gráfico, como qual variável será representada no eixo x, qual será representada no eixo y, a cor e o tamanho dos componentes geométricos etc. Os aspectos que podem ou devem ser mapeados depende do tipo de gráfico que você está construindo. Segue abaixo uma lista dos aspectos visuais mais utilizados: color=: altera a cor de formas que não têm área (pontos e retas). fill=: altera a cor de formas com área (barras, caixas, densidades, áreas). size=: altera o tamanho de formas. type=: altera o tipo da forma, geralmente usada para pontos. linetype=: altera o tipo da linha. Um erro comum na hora de definir atributos estéticos de um gráfico é utilizar a função aes() de forma errada. Repare o que acontece quando tentamos definir diretamente a cor dos pontos dentro dessa função. ggplot(imdb) + geom_point(aes(x = orcamento, y = receita, color = &quot;blue&quot;)) ## Warning: Removed 733 rows containing missing values (geom_point). Estranho, não? O que aconteceu foi o seguinte: a função aes() espera uma variável para ser mapeada a cada atributo, então o valor blue é tratado como uma nova variável/coluna que tem essa string para todas as observações. Assim, todos pontos têm a mesma cor (vermelha, padrão do ggplot) pois pertencem todos à essa “categoria ‘blue’”. No caso, o que gostaríamos é de ter pintado todos os pontos de azul. A forma certa de fazer isso é colocando o atributo color= fora da função aes(): ggplot(imdb) + geom_point(aes(x = orcamento, y = receita), color = &quot;blue&quot;) ## Warning: Removed 733 rows containing missing values (geom_point). Vamos agora explorar novos gráficos a partir da família de funções geom_(). 8.1.3 Formas geométricas Os geoms definem qual forma geométrica será utilizada para a visualização das observações. Como já vimos, a função geom_point() gera gráficos de dispersão transformando pares \\((x,y)\\) em pontos. Veja a seguir outros geoms bastante utilizados: geom_line - para linhas definidas por pares (x,y). geom_abline - para retas definidas por um intercepto e uma inclinação. geom_hline - para retas horizontais. geom_bar - para barras. geom_histogram - para histogramas. geom_boxplot - para boxplots. geom_density - para densidades. geom_area - para áreas. Veja a seguir como é fácil gerar diversos gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima: 8.1.3.1 Linhas imdb %&gt;% filter(diretor == &quot;Steven Spielberg&quot;) %&gt;% group_by(ano) %&gt;% summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %&gt;% ggplot() + geom_line(aes(x = ano, y = nota_media)) ## `summarise()` ungrouping output (override with `.groups` argument) 8.1.3.2 Histograma ggplot(imdb) + geom_histogram(aes(x = orcamento), color = &quot;black&quot;, fill = &quot;white&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 298 rows containing non-finite values (stat_bin). Enquanto o gráfico e dispersão demandam o mapeamento das posições x e y, o histograma requer apenas a posição x, já que, pela definição do gráfico, o eixo mostra a frequência de cada classe. 8.1.3.3 Boxplot imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita)) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Repare que o boxplot pede uma variável categórica no eixo x. 8.1.3.4 Gráfico de barras Há duas formas de fazer um gráfico de barras. A primeira é utilizando a função geom_bar(), quando queremos que a função conte a frequência de cada categoria. imdb %&gt;% filter(ano &gt; 1990) %&gt;% ggplot() + geom_bar(aes(x = ano), color = &quot;black&quot;, fill = &quot;light blue&quot;) Ou a função geom_col(), quando já temos essas contagens. imdb %&gt;% count(diretor) %&gt;% filter(!is.na(diretor)) %&gt;% dplyr::top_n(5, n) %&gt;% ggplot() + geom_bar( aes(x = diretor, y = n), stat = &quot;identity&quot;, color = &quot;red&quot;, fill = &quot;pink&quot; ) 8.1.4 Juntando gráficos No ggplot, temos várias formas de juntar gráficos. Vamos apresentar a seguir as principais. 8.1.4.1 Vários geoms no mesmo gráfico Podemos acrescentar vários geoms em um mesmo gráfico, apenas adicionando novas camadas. No código abaixo, construímos o gráfico de dispersão da receita pelo orçamento dos filmes, acrescentando também uma reta de tendência aos pontos. ggplot(imdb) + geom_point(aes(x = orcamento, y = receita)) + geom_smooth(aes(x = orcamento, y = receita), se = FALSE, method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Warning: Removed 733 rows containing non-finite values (stat_smooth). ## Warning: Removed 733 rows containing missing values (geom_point). Quando estamos usando mais de um geom, podemos economizar código especificando o aes() diretamente na função ggplot(). O mapeamento então é distribuído para todos os geoms do gráfico. ggplot(imdb, aes(x = orcamento, y = receita)) + geom_point() + geom_smooth(se = FALSE, method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Warning: Removed 733 rows containing non-finite values (stat_smooth). ## Warning: Removed 733 rows containing missing values (geom_point). Mas você ainda pode usar o aes() dentro dos geoms para especificar mapeamentos específicos. ggplot(imdb, aes(x = orcamento, y = receita)) + geom_point(aes(color = ano)) + geom_smooth(color = &quot;black&quot;, se = FALSE, method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Warning: Removed 733 rows containing non-finite values (stat_smooth). ## Warning: Removed 733 rows containing missing values (geom_point). 8.1.4.2 Replicando um gráfico para cada categoria de uma variável Uma funcionalidade muito útil do ggplot2 é a possibilidade de usar facets para replicar um gráfico para cada categoria de uma variável. imdb %&gt;% filter(classificacao %in% c(&quot;Livre&quot;, &quot;A partir de 13 anos&quot;)) %&gt;% ggplot() + geom_point(aes(x = orcamento, y = nota_imdb)) + facet_wrap(~classificacao, nrow = 2) ## Warning: Removed 85 rows containing missing values (geom_point). Repare que usamos uma fórmula para dizer à função qual variável vamos utilizar para quebrar o gráfico. Podemos especificar se queremos os gráficos lado a lado ou um embaixo do outro pelos argumentos nrow= e ncol=. imdb %&gt;% filter(classificacao %in% c(&quot;Livre&quot;, &quot;A partir de 13 anos&quot;)) %&gt;% ggplot() + geom_point(aes(x = orcamento, y = nota_imdb)) + facet_wrap(~classificacao, ncol = 2) ## Warning: Removed 85 rows containing missing values (geom_point). Exercício relâmpago! Pesquise o que faz a função facet_grid(). 8.1.4.3 Juntando gráficos diferentes Diversos outros pacotes trazem ferramentas super úteis para trabalharmos com o ggplot2. Um deles é o pacote patchwork. Após carregá-lo, podemos juntar dois gráficos com um simples +. # Instale antes de carregar # devtools::install_github(&quot;thomasp85/patchwork&quot;) library(patchwork) p1 &lt;- imdb %&gt;% filter(diretor == &quot;Steven Spielberg&quot;) %&gt;% group_by(ano) %&gt;% summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %&gt;% ggplot() + geom_line(aes(x = ano, y = nota_media)) ## `summarise()` ungrouping output (override with `.groups` argument) p2 &lt;- imdb %&gt;% mutate(lucro = receita - orcamento) %&gt;% filter(diretor == &quot;Steven Spielberg&quot;) %&gt;% ggplot() + geom_histogram( aes(x = lucro), fill = &quot;lightblue&quot;, color = &quot;darkblue&quot;, binwidth = 100000000 ) p1 + p2 ## Warning: Removed 1 rows containing non-finite values (stat_bin). 8.1.5 Personalizando Como exemplo de personalização de um gráfico com o ggplot2, vamos partir de um simples boxplot e fazer diversas alterações no seu visual. O gráfico inicial é construído da seguinte forma: imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor)) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.5.1 Removendo totalmente a legenda Existem diversas maneiras para remover a legenda de um gráfico no ggplot2. A forma mais simples é usar o argumento show.legend = FALSE dentro do geom. imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.5.2 Mexendo na escala Para mudar qualquer aspecto estético da escala, usamos a família de funções scale_(). No caso, vamos deixar a escala do eixo y no formato de dólares. imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Repare que para cada tipo de atributo, existe uma função scale_() correspondente. 8.1.5.3 Alterando a ordem das categorias Para alterar a ordem que as categorias de uma variável aparecem no gráfico, podemos utilizar o argumento breaks= da função scale_(). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Também é possível fazer isso usando as funções do pacote forcats, apresentado com detalhes aqui. 8.1.5.4 Escolhendo cores manualmente O pacoteggplot2 utiliza uma palheta de cores padrão. Se você quiser especificar as suas próprias cores, faça isso utilizando a função scale_(). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.5.5 Modificando o visual do gráfico Podemos mudar aspectos visuais do gráfico, como fontes, cores e estilos dos textos, grids, marcações, cor do fundo etc, a partir da função theme(). No exemplo abaixo, eliminamos o texto e as marcações do eixo \\(x\\). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor)) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.5.6 Modificando a posição da legenda É possível controlar a posição da legenda facilmente escolhendo uma das posições: left, right, top e bottom. imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor)) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme( axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = &quot;bottom&quot; ) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Existem alguns temas já prontos disponíveis no ggplot2. Veja alguns exemplos. imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme_bw() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme_minimal() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme_dark() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.5.7 Acrescentando título Para acrescentar um título ao seu gráfico, utilize a função ggtitle(). imdb %&gt;% filter(diretor %in% c(&quot;Steven Spielberg&quot;, &quot;Quentin Tarantino&quot;, &quot;Woody Allen&quot;)) %&gt;% ggplot() + geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) + scale_y_continuous(labels = scales::dollar) + scale_x_discrete( limits = c(&quot;Woody Allen&quot;, &quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;) ) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + theme_minimal() + ggtitle(&quot;Meu boxplot bonitão&quot;) ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). 8.1.6 Onde continuar estudando? O pacote ggplot2 tem incontáveis funcionalidades, principalmente na hora de personalizar o seu gráfico. Abordamos aqui apenas algumas poucas delas. Para continuar aprendendo, sugerimos as seguintes referências: O capítulo de visualizações do R4DS é um ótimo material para fixar os conceitos básicos. O capítulo de gráficos do livro R Cookbook é um bom material de consulta para relembrar velhos truques e descobrir novas formas de personalizar seu gráfico. O site ggplot2 extensions tem uma galeria com diversos pacotes que deixam o ggplot2 bem mais poderoso, indo de novos geoms até animações. library(ggridges) imdb %&gt;% filter(ano &gt; 2005) %&gt;% mutate(ano = as.factor(ano)) %&gt;% ggplot(aes(y = ano, x = receita, fill = ano)) + geom_density_ridges(na.rm = TRUE, show.legend = FALSE) ## Picking joint bandwidth of 17300000 8.1.7 Exercícios 1. O que tem de errado no código abaixo? Por que os pontos não ficaram azuis? ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;)) 2. Mapeie uma variável contínua para uma cor, tamanho e forma. Como essas formas estéticas se comportam diferente para variáveis categóricas vs contínuas? 3. O que acontece se você rodar ggplot(data = mtcars)? 4. Utilizando o mtcars, faça um gráfico de dispersão de mpg por qsec. 5. Utilizando o mtcars, o que acontece se você fizer um gráfico de dispersão de vs por mpg? Por que o gráfico não é útil? "],["8-2-o-pacote-plotly.html", "8.2 O pacote plotly", " 8.2 O pacote plotly "],["8-3-extensões-do-ggplot2.html", "8.3 Extensões do ggplot2", " 8.3 Extensões do ggplot2 "],["9-relatorios.html", "Capítulo 9 Relatórios", " Capítulo 9 Relatórios Depois de fazer toda a nossa análise dentro do R, não é justamente na hora de mostrá-la ao mundo que vamos abandonar as vantagens de estarmos dentro de uma linguagem de programação. Com a ajuda do R Markdown, uma interface de anotações que combina texto livre com códigos em R, podemos construir relatórios não só reprodutíveis, mas elegantemente bem formatados, sem sair do R! Figura 9.1: Ilustração por Allison Horst. Além do próprio {rmarkdown}, existem diversos pacotes que podem ser utilizados para ampliar os produtos que elaboramos com R Markdown. Podemos criar/escrever: blogs e sites — blogdown e distill; livros (como este!) — bookdown; apresentações — xaringan; currículos, cartas e trabalhos acadêmicos — pagedown; tutoriais interativos — learnr; artigos científicos — rticles. Antes de mais nada, vamos instalar os pacotes {rmarkdown} e {knitr}. O primeiro reune todas as funcionalidades para juntar nossos textos narrativos e códigos de R. O segundo vai fazer a magia de transformar nossos simples arquivos de texto em arquivos HTML, PDF e Word (.doc) bonitões. install.packages(c(&quot;rmarkdown&quot;, &quot;knitr&quot;)) Nas seções a seguir, vamos mostrar como começar a utilizar o R Markdown para criar esses documentos. Não se esqueça de conferir (e deixar por perto) as folhas de cola sobre R Markdown: rmarkdown cheatsheet rmarkdown cheatsheet 2.0 "],["9-1-markdown.html", "9.1 Markdown", " 9.1 Markdown Se você é uma pessoa que utiliza R, sabe das possibilidades de utilizar R Markdown (e os pacotes que expandem mais ainda as possibilidades) e gostaria de começar a utilizá-lo, é importante conhecer o Markdown. Por quê? O R Markdown tem como base a linguagem de marcação Markdown. Os arquivos markdown podem ser abertos por qualquer software que suporte este formato aberto. Além disso, independente da plataforma de trabalho, pode-se migrar para um arquivo de texto sem perder a formatação. O Markdown também é usado em outros lugares, como no GitHub e no Fórum da Curso-R. Uma referência interessante para ter sempre em mãos é a Folha de cola (Cheatsheet) do Markdown. Nas seções seguintes, descreveremos como podemos marcar os nossos textos e códigos usando markdown, e você poderá usar isso tanto em arquivos .Rmd, quanto em outros lugares que também utilizam essa marcação (como no Fórum da Curso-R!). 9.1.1 Ênfase Negrito Para destacar um texto em negrito, coloque ** ou __ ao redor do texto. Por exemplo: Como é escrito no código Como aparece no relatório Esse é um texto com uma palavra destacada em **negrito**. Esse é um texto com uma palavra destacada em negrito. Esse é um texto com uma palavra destacada em __negrito__. Esse é um texto com uma palavra destacada em negrito. Itálico Para destacar um texto em itálico, coloque * ou _ ao redor do texto. Por exemplo: Como é escrito no código Como aparece no relatório Esse é um texto com uma palavra destacada em *itálico*. Esse é um texto com uma palavra destacada em itálico. Esse é um texto com uma palavra destacada em _itálico_. Esse é um texto com uma palavra destacada em itálico. Riscado (ou tachado) Para riscar/tachar um texto, coloque ~~ ao redor do texto. Por exemplo: Esse é um texto com uma palavra riscada/tachada. Como é escrito no código Como aparece no relatório Esse é um texto com uma palavra ~~riscada/tachada~~. Esse é um texto com uma palavra riscada/tachada. 9.1.2 Títulos Os títulos funcionam como uma hierarquia, e para criar um título é necessário colocar um # no início da linha. Então um # marca um título, ## marca um sub-título, e assim sucessivamente. Veja os exemplos: Como é escrito no código Como aparece no relatório # Título 1 ## Título 2 ### Título 3 9.1.3 Listas Listas ordenadas Você pode fazer uma lista ordenada usando somente números. Você pode repetir o número quantas vezes quiser: Como é escrito no código: 1. Maçã 1. Banana 1. Uva Como aparece no relatório: Maçã Banana Uva Listas não ordenadas Você pode fazer uma lista não ordenada escrevendo com hífens ou asteriscos, como a seguir: * Maçã * Banana * Uva - Maçã - Banana - Uva O resultado será: Maçã Banana Uva Você também pode adicionar sub-itens na lista indicando a hierarquia através da identação no Markdown (dica: utilize a tecla tab do teclado): Frutas Maçã Banana Uva 9.1.4 Equações Você pode adicionar equações utilizando LaTeX. Você pode saber mais na página do Overleaf sobre expressões matemáticas. Além disso, existem geradores de equações online que ajudam a escrevâ-las em LaTeX, HTML, entre outras linguagens de marcação. É possível centralizar a equação envolvendo o código com $$. Veja o exemplo abaixo: Como é escrito no código Como aparece no relatório $$y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon$$ \\[y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon\\] Também é possível adicionar a equação na mesma linha que o texto, envolvendo o código com $. Veja o exemplo abaixo: Como é escrito no código Como aparece no relatório Ou também na linha $y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon$ , junto ao texto! Ou também na linha \\(y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon\\) , junto ao texto! 9.1.5 Código É possível marcar textos para que fiquem formatados como códigos, usando a crase: ` Mas atenção: o texto será formatado como código, porém não será executado! Como é escrito no código Como aparece no relatório `mean(pinguins$massa_corporal, na.rm = TRUE)` mean(pinguins$massa_corporal, na.rm = TRUE) Também é possível delimitar um trecho maior de código, utilizando três crases. Exemplo: Como é escrito no código: ``` library(dados) mean(pinguins$massa_corporal, na.rm = TRUE) ``` Como aparece no relatório: library(dados) mean(pinguins$massa_corporal, na.rm = TRUE) 9.1.6 Links Você pode criar um link utilizando esta estrutura: [texto](http://url-da-pagina.com). Por exemplo: Como é escrito no código Como aparece no relatório Você pode consultar mais [materiais sobre R nesta página](https://curso-r.com/material/). Você pode consultar mais materiais sobre R nesta página. 9.1.7 Imagens Você pode incluir uma imagem utilizando esta estrutura: ![descricao da imagem](http://url-da-imagem.com). Não se esqueça: a descrição da imagem é importante para acessibilidade do conteúdo através de leitores de tela! Como é escrito no código Como aparece no relatório ![Logo da Curso-R](https://raw.githubusercontent.com/curso-r/site-v2/master/static/img/logo_cursor_full.png) 9.1.8 Tabelas As tabelas em Markdown têm uma estrutura definida, como mostra o exemplo abaixo. É possível usar ferramentas online para gerar tabelas em Markdown, como por exemplo o Tables Generator. Em Markdown: | a| b| c| |--:|--:|--:| | 1| 2| 3| | 2| 3| 4| Resultado: a b c 1 2 3 2 3 4 9.1.9 Recapitulando Nesta seção, aprendemos que o Markdown é uma linguagem de marcação, usada para marcar textos. Podemos usar o Markdown para formatar textos e adicionar elementos no nossos relatórios. Porém existem elementos (como código, imagens, tabelas, entre outros) que podemos também adiconar nos relatórios utilizando R. É isso que veremos na seção seguinte! "],["9-2-r-markdown.html", "9.2 R Markdown", " 9.2 R Markdown O R Markdown é a junção da linguagem Markdown com o poder de códigos em R. A mágica aconte em arquivos do tipo .Rmd, onde é possível adicionar textos, códigos, resultados de códigos e muito mais! Nesta seção, utilizaremos como exemplos alguns códigos envolvendo a base de dados de pinguins. A versão original deste dataset (em Inglês) está disponível no pacote palmerpenguins, e a versão traduzida para Português está disponível no pacote dados. Figura 9.1: Conheça os Pinguins do dataset PalmerPenguins! Ilustração por Allison Horst. Caso não tenha o pacote dados instalado, é possível instalar com o seguinte código: install.packages(&quot;remotes&quot;) remotes::install_github(&quot;cienciadedatos/dados&quot;) Agora carregue os pacotes necessários: library(dados) # Pacote com bases de dados em Português library(magrittr) # Pacote para utilizar o Pipe %&gt;% 9.2.1 Códigos em R Ao analisar dados, escrevemos códigos que calculam estatísticas descritivas, geram gráficos e tabelas, entre outros. Para adicionar esses resultados nos relatórios, não é muito prático adicionar manualmente o resultado final (copiando e colando, por exemplo), pois em caso de alguma mudança na base de dados, será necessário gerar novamente estes resultados e adicioná-los novamente! Com RMarkdown, podemos adicionar códigos nos nossos relatórios que geram os resultados, assim a cada vez que compilarmos o relatório os códigos que geram estes resultados serão executados, e o relatório terá sempre os resultados atualizados. Caso você queira que o código seja executado como código R, existem duas possibilidades: chunks de código ou campos de código ( chunks em Inglês), quando o código é executado em um campo de código em R. código em linha (ou ‘inline code’ em Inglês), quando o resultado aparece junto ao texto; Campos de código (chunks) É possível adicionar campos de código utilizando a seguinte sintaxe: ```{r} codigo em R aqui ``` Um exemplo de campo de código é o campo abaixo, onde é possível executar o código e visualizar o resultado. Exemplo: ```{r} # calcula a média media_massa_g &lt;- mean(pinguins$massa_corporal, na.rm = TRUE) # converte de gramas para kilogramas media_massa_kg_completo &lt;- media_massa_g / 1000 # arredonda o valor para ter uma casa decimal media_massa_kg &lt;- round(media_massa_kg_completo, 1) # exibe o resultado media_massa_kg ``` Resultado: # calcula a média media_massa_g &lt;- mean(pinguins$massa_corporal, na.rm = TRUE) # converte de gramas para kilogramas media_massa_kg_completo &lt;- media_massa_g / 1000 # arredonda o valor para ter uma casa decimal media_massa_kg &lt;- round(media_massa_kg_completo, 1) # exibe o resultado media_massa_kg ## [1] 4.2 Veja que no resultado obtivemos o código em R e também o resultado deste código. Dependendo do público alvo do relatório, não queremos mostrar códigos. É possível escondê-los (e fazer muito mais!) alterando as opções de chunks (ou chunk options em Inglês). Veremos mais sobre isso posteriormente! Inline code Para que um resultado de código apareça ao longo do texto, é possivel usar a seguinte estrutura: `r ` . Exemplo: A média da massa corporal dos pinguins é `r media_massa_kg` kg. Resultado: A média da massa corporal dos pinguins é 4.2 kg. 9.2.2 Imagens Na seção anterior (sobre Markdown), mostramos como é possóvel adicionar uma imagem em um relatório utilizando Markdown. Porém, quando utilizamos arquivos RMarkdown também podemos adicionar imagens usando código em R, com a função include_graphics do pacote knitr. Usando o knitr é possível personalizar de forma mais intuitiva como a imagem aparecerá no arquivo final: você pode adicionar uma imagem utilizando como primeiro argumento a url da imagem ou o caminho onde ela está no projeto. Além disso, com as opções de chunks (ou chunk options em Inglês), poderemos personalizar diversos atributos da imagem, como: legenda, tamanho, alinhamento, entre outros. Veja o exemplo abaixo: knitr::include_graphics(&quot;https://cienciadedatos.github.io/dados/reference/figures/dados-hex.png&quot;) 9.2.3 Tabelas Na seção anterior (sobre Markdown), foi apresentado como adicionar uma tabela utilizando Markdown. Porém quando utilizamos arquivos R Markdown também é possível adicionar tabelas que resultam de códigos em R. Existem algumas funções diferentes para fazer isso. Para apresentar alguns exemplos, primeiramente vamos salvar uma versão da base pinguins: media_massa &lt;- pinguins %&gt;% # usamos a base de pinguins # agrupamos por especies e ilhas dplyr::group_by(especies, ilha) %&gt;% # calculamos a média da massa corporal dplyr::summarise(media_massa = mean(massa_corporal, na.rm = TRUE)) %&gt;% # criamos uma nova coluna, com a massa em kg, e arredondada com 2 casas decimais dplyr::mutate(media_massa_kg = round(media_massa / 1000, 2)) %&gt;% # removemos a coluna da massa em gramas dplyr::select(-media_massa) # Apresentamos o resultado da tabela: media_massa ## # A tibble: 5 x 3 ## # Groups: especies [3] ## especies ilha media_massa_kg ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 Pinguim-de-adélia Biscoe 3.71 ## 2 Pinguim-de-adélia Dream 3.69 ## 3 Pinguim-de-adélia Torgersen 3.71 ## 4 Pinguim-de-barbicha Dream 3.73 ## 5 Pinguim-gentoo Biscoe 5.08 Acima, a tabela é apresentada como ela é escrita no console do R. Porém essa forma não é elegante de ser apresentada em um relatório! Podemos utilizar funções de diferentes pacotes para que as tabelas fiquem formatadas de uma forma mais atraente: Utilizando o pacote knitr: função kable() media_massa %&gt;% knitr::kable() especies ilha media_massa_kg Pinguim-de-adélia Biscoe 3.71 Pinguim-de-adélia Dream 3.69 Pinguim-de-adélia Torgersen 3.71 Pinguim-de-barbicha Dream 3.73 Pinguim-gentoo Biscoe 5.08 Utilizando o pacote DT: função datatable() media_massa %&gt;% DT::datatable() Os exemplos anteriores são as formas mais simples de apresentar as tabelas, porém cada pacote possibilita diferentes personalizações (por exemplo, alterar o nome das colunas, etc). Existem outros pacotes que permitem adicionar tabela nos relatórios em RMarkdown, como por exemplo: reactable flextable kableExtra 9.2.4 Dicas para o RStudio A versão mais recente do RStudio possui uma ferramenta de edição de Markdown visual, que disponibiliza botões para editar o texto com Markdown. Veja mais neste post no blog da RStudio, e também a animação disponível neste post: Figura 9.2: Demonstração do RStudio versão 1.4 "],["10-funcionais.html", "Capítulo 10 Funcionais", " Capítulo 10 Funcionais "],["11-misc.html", "Capítulo 11 Miscelânea ", " Capítulo 11 Miscelânea "],["11-1-arrumando-banco-de-dados-o-pacote-janitor.html", "11.1 Arrumando banco de dados: o pacote janitor", " 11.1 Arrumando banco de dados: o pacote janitor Vamos falar do pacote janitor, que traz algumas funções para dar aquele trato nas BDs. Antes de mais nada, instale e carregue o pacote: install.packages(&quot;janitor&quot;) devtools::install_github(&quot;sfirke/janitor&quot;) # Versão de desenvolvimento library(tidyverse) library(janitor) 11.1.1 Arrumando o nome das variáveis Assim como no post passado, utilizaremos a base com informações de pacientes com arritmia cardíaca, cujas variáveis selecionadas foram: dados %&gt;% names() ## [1] &quot;ID&quot; &quot;Sexo&quot; &quot;Nascimento&quot; ## [4] &quot;Idade&quot; &quot;Inclusão&quot; &quot;Cor&quot; ## [7] &quot;Peso&quot; &quot;Altura&quot; &quot;cintura&quot; ## [10] &quot;IMC&quot; &quot;Superfície corporal&quot; &quot;Tabagismo&quot; ## [13] &quot;cg.tabag (cig/dia)&quot; &quot;Alcool (dose/semana)&quot; &quot;Drogas ilícitas&quot; ## [16] &quot;Cafeína/dia&quot; &quot;Refrig/dia&quot; &quot;Sedentario&quot; ## [19] &quot;ativ. Fisica&quot; Os nomes têm letras maiúsculas, acentos, parênteses, pontos e barras, o que atrapalha na hora da programação. Para resolver esse problema, usamos a função clean_names(). dados %&gt;% janitor::clean_names() %&gt;% names() ## [1] &quot;id&quot; &quot;sexo&quot; &quot;nascimento&quot; ## [4] &quot;idade&quot; &quot;inclusao&quot; &quot;cor&quot; ## [7] &quot;peso&quot; &quot;altura&quot; &quot;cintura&quot; ## [10] &quot;imc&quot; &quot;superficie_corporal&quot; &quot;tabagismo&quot; ## [13] &quot;cg_tabag_cig_dia&quot; &quot;alcool_dose_semana&quot; &quot;drogas_ilicitas&quot; ## [16] &quot;cafeina_dia&quot; &quot;refrig_dia&quot; &quot;sedentario&quot; ## [19] &quot;ativ_fisica&quot; Veja que a função removeu os parênteses, pontos e barras e substituiu os espaços por _. No entanto, ela não remove os acentos. Assim, podemos adicionar mais uma linha ao pipeline para chegar onde queremos. dados %&gt;% janitor::clean_names() %&gt;% names() %&gt;% abjutils::rm_accent() ## [1] &quot;id&quot; &quot;sexo&quot; &quot;nascimento&quot; ## [4] &quot;idade&quot; &quot;inclusao&quot; &quot;cor&quot; ## [7] &quot;peso&quot; &quot;altura&quot; &quot;cintura&quot; ## [10] &quot;imc&quot; &quot;superficie_corporal&quot; &quot;tabagismo&quot; ## [13] &quot;cg_tabag_cig_dia&quot; &quot;alcool_dose_semana&quot; &quot;drogas_ilicitas&quot; ## [16] &quot;cafeina_dia&quot; &quot;refrig_dia&quot; &quot;sedentario&quot; ## [19] &quot;ativ_fisica&quot; E para substituir na base. nomes &lt;- dados %&gt;% janitor::clean_names() %&gt;% names() %&gt;% abjutils::rm_accent() names(dados) &lt;- nomes 11.1.2 Removendo linhas e colunas vazias Esse banco de dados também tinha outro problema: linhas vazias. Na verdade, elas não eram completamente vazias, pois havia algumas informações de identificação do paciente, mas nenhuma outra variável tinha sido computada. dados[3,] ## # A tibble: 1 x 19 ## id sexo nascimento idade inclusao cor peso altura ## &lt;int&gt; &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 &lt;NA&gt; NA NA NA &lt;NA&gt; NA NA ## # … with 11 more variables: cintura &lt;chr&gt;, imc &lt;dbl&gt;, ## # superficie_corporal &lt;chr&gt;, tabagismo &lt;chr&gt;, cg_tabag_cig_dia &lt;dbl&gt;, ## # alcool_dose_semana &lt;dbl&gt;, drogas_ilicitas &lt;chr&gt;, cafeina_dia &lt;dbl&gt;, ## # refrig_dia &lt;dbl&gt;, sedentario &lt;chr&gt;, ativ_fisica &lt;chr&gt; Essa foi a solução que eu pensei para resolver o problema utilizando a função remove_empty(). dados &lt;- dados %&gt;% as.data.frame %&gt;% dplyr::select(-id) %&gt;% janitor::remove_empty() %&gt;% tibble::rownames_to_column(&quot;id&quot;) %&gt;% dplyr::select(id, everything()) ## value for &quot;which&quot; not specified, defaulting to c(&quot;rows&quot;, &quot;cols&quot;) dados %&gt;% tibble::as_tibble() ## # A tibble: 4 x 19 ## id sexo nascimento idade inclusao cor peso altura ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 F 1964-01-31 00:00:00 41 2006-02-17 00:00:00 bran… 75 1.63 ## 2 2 M 1959-01-28 00:00:00 45 2005-11-29 00:00:00 negra 71 1.7 ## 3 4 M 1957-09-13 00:00:00 50 2008-02-13 00:00:00 NT 80 1.64 ## 4 5 F 1938-02-06 00:00:00 71 2009-06-25 00:00:00 parda 56 1.51 ## # … with 11 more variables: cintura &lt;chr&gt;, imc &lt;dbl&gt;, ## # superficie_corporal &lt;chr&gt;, tabagismo &lt;chr&gt;, cg_tabag_cig_dia &lt;dbl&gt;, ## # alcool_dose_semana &lt;dbl&gt;, drogas_ilicitas &lt;chr&gt;, cafeina_dia &lt;dbl&gt;, ## # refrig_dia &lt;dbl&gt;, sedentario &lt;chr&gt;, ativ_fisica &lt;chr&gt; Eu precisei converter para data.frame primeiro porque não é possível definir os nomes das linhas de uma tibble. Se a linha estivesse completamente vazia, bastaria usar diretamente a função remove_empty_rows(). Equivalentemente para colunas, existe a função remove_empty_cols(). 11.1.3 Identificando linhas duplicadas O pacote janitor possui uma função para identificar entradas duplicadas numa base de dados: get_dupes(). Vamos criar uma base genérica para testá-la. p_nome &lt;- c(&quot;Athos&quot;, &quot;Daniel&quot;, &quot;Fernando&quot;, &quot;Julio&quot;, &quot;William&quot;) sobrenome &lt;- c(&quot;Damiani&quot;, &quot;Falbel&quot;, &quot;Corrêa&quot;, &quot;Trecenti&quot;, &quot;Amorim&quot;) base_qualquer &lt;- tibble::tibble( nome = sample(p_nome, 25, replace = TRUE), sobrenome = sample(sobrenome, 25, replace = TRUE), variavel_importante = rnorm(25) ) janitor::get_dupes(base_qualquer, nome, sobrenome) ## # A tibble: 15 x 4 ## nome sobrenome dupe_count variavel_importante ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Athos Trecenti 3 0.691 ## 2 Athos Trecenti 3 -0.542 ## 3 Athos Trecenti 3 0.841 ## 4 Daniel Trecenti 2 0.349 ## 5 Daniel Trecenti 2 0.357 ## 6 Fernando Trecenti 4 0.0305 ## 7 Fernando Trecenti 4 0.0191 ## 8 Fernando Trecenti 4 -0.221 ## 9 Fernando Trecenti 4 1.35 ## 10 Julio Falbel 2 0.444 ## 11 Julio Falbel 2 -1.78 ## 12 Julio Trecenti 2 -0.820 ## 13 Julio Trecenti 2 -0.0894 ## 14 William Corrêa 2 0.0874 ## 15 William Corrêa 2 0.129 Todas as linhas na tibble resultante representam uma combinação de nome-sobrenome repetida. 11.1.4 Outras funções Por fim, o janitor também tem funções equivalentes à table() para produzir tabelas de frequência: tabyl() - similar a table(), mas pipe-ável e com mais recursos. adorn_totals() - acrescenta o total das linhas ou colunas. mtcars %&gt;% janitor::tabyl(cyl) ## cyl n percent ## 4 11 0.34375 ## 6 7 0.21875 ## 8 14 0.43750 mtcars %&gt;% janitor::tabyl(cyl) %&gt;% janitor::adorn_totals() ## cyl n percent ## 4 11 0.34375 ## 6 7 0.21875 ## 8 14 0.43750 ## Total 32 1.00000 mtcars %&gt;% janitor::tabyl(cyl, am) %&gt;% janitor::adorn_totals(where = &quot;col&quot;) ## cyl 0 1 Total ## 4 3 8 11 ## 6 4 3 7 ## 8 12 2 14 É isso! Espero que essas dicas e o pacote janitor ajudem a agilizar as suas análises :) "],["12-respostas.html", "Capítulo 12 Respostas", " Capítulo 12 Respostas Não há apenas uma maneira de resolver os exercícios. Você pode encontrar soluções diferentes das nossas, algumas vezes mais práticas e eficientes, outras vezes menos. Quando estiver fazendo suas análises, tente buscar o equilíbrio entre eficiência e pragmatismo. Economizar 1 hora com a execução do código pode não valer a pena se você demorou 2 horas a mais para programá-lo. "],["12-1-r-básico.html", "12.1 R básico", " 12.1 R básico R como calculadora 1. Qual a diferença entre o R e o RStudio? O R é uma linguagem de programação e um programa que instalamos no nosso computador para interpretar código em linguagem R. O RStudio é um ambiente de desenvolvimento para programação em R, isto é, é um programa que nos ajuda a trabalhar com a linguagem R. 2. Podemos usar o RStudio sem o R? E o R sem o RStudio? Não podemos usar o RStudio sem o R, pois o programa R é que interpreta os nossos códigos e devolve os resultados. Por outro lado, podemos usar o R sem o RStudio (ou qualquer outro ambiente de desenvolvimento), mas a nossa vida de pessoa programadora se torna muito mais difícil. 3. Precisamos compilar nossos códigos de R? Não. Um código em R é interpretado linha a linha, isto é, podemos ir rodando nosso código parcialmente, conforme vamos escrevendo. 4. Calcule o número de ouro no R. Dica: o número de ouro é dado pela expressão \\(\\frac{1 + \\sqrt{5}}{2}\\). (1 + 5^(1 / 2))/2 ## [1] 1.618034 Também poderia ser resolvido usando a função sqrt() para calcular a raiz quadrada. (1 + sqrt(5))/2 ## [1] 1.618034 5. Por que é preferível escrevermos sempre o nosso código no script e não no Console? Porque o código é a documentação da nossa análise. Se parte da análise for feita diretamente no Console, parte da documentação será perdida. Objetos e funções 1. Qual a diferença entre os códigos abaixo? # Código 1 33 / 11 # Código 2 divisao &lt;- 33 / 11 O primeiro código calcula a divisão de 33 por 11 e devolve o resultado na tela. O segundo código faz o mesmo cálculo, mas guardo o resultado no objeto divisao, isto é, o resultado não é retornado na tela. 2. Multiplique a sua idade por meses e salve o resultado em um objeto chamado idade_em_meses. Em seguida, multiplique esse objeto por 30 e salve o resultado em um objeto chamado idade_em_dias. idade_em_meses &lt;- 31 * 12 idade_em_dias &lt;- idade_em_meses * 30 3. Por que o nome meu-objeto não pode ser utilizado para criar um objeto? O que significa a mensagem de erro resultante? meu-objeto &lt;- 1 ## Error in meu - objeto &lt;- 1: object &#39;meu&#39; not found Porque o sinal - é utilizado pelo R como o operador de subtração. O código acima está sendo interpretado como a subtração dos objetos meu e objeto. Como nenhum dos objetos existe na sessão, é devolvido um erro dizendo que o objeto meu (o primeiro deles) não foi encontrado. No entanto, mesmo que os objetos existissem, seria retornado um erro. Neste caso, seria um erro de sintaxe, pois o R não sabe como interpretar a atribuição do valor 3 à operação meu - objeto. Veja que a mensagem de erro não é muito intuitiva, pois o R entende que -&lt;- é uma função que esquecemos de definir. meu &lt;- 1 objeto &lt;- 2 meu-objeto &lt;- 1 ## Error in meu - objeto &lt;- 1: could not find function &quot;-&lt;-&quot; Classes 1. Guarde em um objeto chamado nome uma string contendo o seu nome completo. nome &lt;- &quot;William Nilson de Amorim&quot; 2. Guarde em um objeto chamado cidade o nome da cidade onde você mora. Em seguida, guarde em um objeto chamado estado o nome do estado onde você mora. Usando esses objetos, resolva os itens abaixo: a. Utilize a função nchar() para contar o número de caracteres em cada cada string. cidade &lt;- &quot;São Paulo&quot; estado &lt;- &quot;SP&quot; nchar(cidade) ## [1] 9 nchar(estado) ## [1] 2 b. Interprete o resultado do seguinte código: paste(cidade, estado) ## [1] &quot;São Paulo SP&quot; A função paste juntou (colou) as duas strings, uma do lado da outra, separando-as por um espaço. O resultado gerado foi uma única string. c. Interprete o resultado do seguinte código: paste(cidade, estado, sep = &quot; - &quot;) ## [1] &quot;São Paulo - SP&quot; O argumento sep da função paste() nos permite escolher qual caracter será utilizado para separar as duas strings. Por padrão será utilizado um espaço em branco \" \". No exemplo, foi utilizado um espaço, seguido de um traço, seguido de outro espaço. Sem os espaços o resultado seria: paste(cidade, estado, sep = &quot;-&quot;) ## [1] &quot;São Paulo-SP&quot; Veja que qualquer caracter ou string pode ser utilizada como separador: paste(cidade, estado, sep = &quot; #tricolor &quot;) ## [1] &quot;São Paulo #tricolor SP&quot; d. Desafio. Como você reproduziria o mesmo resultado do item (c) sem utilizar o argumento sep? paste(cidade, &quot;-&quot;, estado) ## [1] &quot;São Paulo - SP&quot; e. Qual a diferença entre as funções paste() e paste0()? A função paste0() é equivalente à função paste() com o argumento sep = \"\". paste(cidade, &quot;-&quot;, estado) ## [1] &quot;São Paulo - SP&quot; paste(cidade, &quot;-&quot;, estado, sep = &quot;&quot;) ## [1] &quot;São Paulo-SP&quot; paste0(cidade, &quot;-&quot;, estado) ## [1] &quot;São Paulo-SP&quot; Vetores 1. Guarde em um objeto a sequência de números de 0 a 5 e resolva os itens abaixos. a. Use subsetting para fazer o R devolver o primeiro número dessa sequência. Em seguida, faça o R devolver o último número da sequência. vetor &lt;- 0:5 # Primeiro elemento vetor[1] ## [1] 0 # Último elemento vetor[6] ## [1] 5 b. Multiplique todos os valores do vetor por -1. Guarde o resultado em um novo objeto chamado vetor_negativo. vetor_negativo &lt;- vetor * -1 vetor_negativo ## [1] 0 -1 -2 -3 -4 -5 2. Crie um vetor com o nome de tres frutas, guarde em um objeto chamado frutas e resolva os itens abaixo. a. Utilize a a função length() para verificar o tamanho do vetor. frutas &lt;- c(&quot;banana&quot;, &quot;maçã&quot;, &quot;mamão&quot;) length(frutas) ## [1] 3 b. Inspecione a saída de paste(\"eu gosto de\", frutas) e responda se o tamanho do vetor mudou. paste(&quot;eu gosto de&quot;, frutas) ## [1] &quot;eu gosto de banana&quot; &quot;eu gosto de maçã&quot; &quot;eu gosto de mamão&quot; O tamanho do vetor não muda. O que aconteceu foi o acréscimo do prefixo “eu gosto de” a cada valor do vetor frutas. Podemos confirmar essa afirmação calculando o comprimento do novo vetor: length(paste(&quot;eu gosto de&quot;, frutas)) ## [1] 3 3. O que é reciclagem? Escreva um código em R que exemplifique esse comportamento. Reciclagem é a repetição de valores de um vetor para que uma operação com vetores de tamanhos diferentes possa ser realizada. Embora pareça um comportamento estranho, utilizamos a reciclagem o tempo todo dentro do R, muitas vezes sem perceber. No exemplo a seguir, os valores do vetor_menor serão repetidos (reciclados) até o dois vetores terem o mesmo tamanho. Então, o primeiro valor do vetor menor será somado com o promeiro valor do vetor maior, o segundo do menor somado com o segundo do maior e assim por diante. # Exemplo vetor_menor &lt;- c(1, 3) vetor_maior &lt;- c(1, 2, 3, 4) vetor_menor + vetor_maior ## [1] 2 5 4 7 4. O que é coerção? Escreva um código em R que exemplifique esse comportamento. Coerção é a homogenização da classe dos valores de um vetor. Se construirmos um vetor com valores de classes diferentes, todos os valores serão reprimidos para a classe mais dominante entre eles. No exemplo abaixo, todos os valores do vetor foram transformados em character, pois character é mais dominante do que as demais classes presentes (numeric e logical). Considerando apenas as principais classes, temos a seguinte ordem de dominância: character &gt; numeric &gt; integer &gt; logical. c(1, -3, &quot;a&quot;, TRUE) ## [1] &quot;1&quot; &quot;-3&quot; &quot;a&quot; &quot;TRUE&quot; 5. Por que a coerção pode ser um problema na hora de importarmos bases de dados para o R? Porque as colunas podem acabar sendo importadas com uma classe diferente daquela que estamos esperando e nenhum erro ou warning será devolvido. Por exemplo, se uma coluna da base que deveria ser numérica tiver, por algum descuido, qualquer tipo de caracter não numérico (texto), toda a coluna será importada como texto. O caso mais comum desse problema é gerado pelo separador de decimais. Se não especificarmos corretamente qual é o separador de decimais que estamos utilizando na nossa base de dados na hora da importação, qualquer coluna com valores decimais será importada como texto. 6. Use a função sum() para somar os valores de 1 a 100. sum(1:100) ## [1] 5050 7. Considere o vetor booleano a seguir: dolar_subiu &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE) Este vetor tem informação de uma semana (7 dias, começando no domingo) indicando se o dólar subiu (TRUE) ou não subiu (FALSE) no respectivo dia. Interprete o resultado dos códigos abaixo: a. length(dolar_subiu) length(dolar_subiu) ## [1] 7 Devolve o comprimento do vetor dolar_subiu. Podemos interpretar como o número de dias analisados nesse estudo. b. dolar_subiu[2] dolar_subiu[2] ## [1] TRUE Verifica se o dólar subiu no segundo dia do estudo (segunda-feira). c. sum(dolar_subiu) sum(dolar_subiu) ## [1] 4 Verifica o número de dias que o dólar subiu (já que na soma, os valores TRUE viram 1 e os valores FALSE viram 0), no caso, 4 dias com alta do dólar. d. mean(dolar_subiu) mean(dolar_subiu) ## [1] 0.5714286 Verifica a proporção de dias em que o dólar subiu (a média de valores 0 e 1 é igual a proporção de valores 1), no caso, cerca de 57% dos dias. Testes lógicos 1. O código abaixo vai guardar no objeto segredo um número inteiro entre 0 e 10. Sem olhar qual número foi guardado no objeto, resolva os itens a seguir: segredo &lt;- round(runif(1, min = 0, max = 10)) a. Teste se o segredo é maior ou igual a 0. segredo &gt;= 0 ## [1] TRUE b. Teste se o segredo é menor ou igual a 10. segredo &lt;= 10 ## [1] TRUE c. Teste se o segredo é maior que 5. segredo &gt; 5 ## [1] FALSE d. Teste se o segredo é par. Precisamos verificar se o resto da divisão por 2 é igual a zero. # Resto da divisão por 2 segredo %% 2 ## [1] 1 # Guardando o resultado resto &lt;- segredo %% 2 # Teste resto == 0 ## [1] FALSE # Equivalentemente poderíamos fazer segredo %% 2 == 0 ## [1] FALSE e. Teste se segredo * 5 é maior que a sua idade. segredo * 5 &gt; 31 ## [1] FALSE f. Desafio. Escreva um teste para descobrir o valor do segredo. Vamos descobrir a posição do segredo no vetor 0:10. numeros_possiveis &lt;- 0:10 numeros_possiveis ## [1] 0 1 2 3 4 5 6 7 8 9 10 segredo == numeros_possiveis ## [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE No código acima, para cada valor de numero_possiveis, foi testado se esse valor é igual ao segredo. Em caso afirmativo, um TRUE é devolvido. Veja que há apenas um TRUE no vetor resultante. Essa é posição do nosso segredo dentro do vetor numeros_possiveis. Podemos usar esse vetor de TRUE/FALSE para recuperar o valor do segredo fazendo subsetting. # Eis o valor do segredo numeros_possiveis[segredo == numeros_possiveis] ## [1] 1 No código acima, foi retornado apenas o número associado ao valor TRUE dado pelo teste segredo == numeros_possiveis. 2. Escreva um código em R que devolva apenas os valores maiores ou iguais a 10 do vetor abaixo: vetor &lt;- c(4, 8, 15, 16, 23, 42) # Resposta vetor[vetor &gt;= 10] ## [1] 15 16 23 42 3. Use o vetor numeross abaixo para responder as questoes seguintes. numeros &lt;- -4:2 a. Escreva um código que devolva apenas valores positivos do vetor numeros. numeros[numeros &gt; 0] ## [1] 1 2 b. Escreva um código que devolta apenas os valores pares do vetor numeros. # Resto da divisão por 2 numeros %% 2 ## [1] 0 1 0 1 0 1 0 # Quais números são pares? numeros %% 2 == 0 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE # Usando para filtrar o vetor numeros[numeros %% 2 == 0] ## [1] -4 -2 0 2 c. Filtre o vetor para que retorne apenas aqueles valores que, quando elevados a 2, são menores do que 4. # Quadrado dos valores do vetor numeros^2 ## [1] 16 9 4 1 0 1 4 # Aqueles menores que 4 numeros^2 &lt; 4 ## [1] FALSE FALSE FALSE TRUE TRUE TRUE FALSE # Usando para filtrar numeros[numeros^2 &lt; 4] ## [1] -1 0 1 Valores especiais 1. Quais as diferenças entre NaN, NULL, NA e Inf? Digite expressões que retornem cada um desses valores. O NaN representa uma indefinição matemática. Todo NaN é um NA, mas o contrário não é verdade. 0/0 ## [1] NaN O NA representa o nosso desconhecimento acerca de um valor. Esse valor existe, mas nós não o conhecemos. Na Estatística, ele é conhecido como valor omisso ou valor faltante. sum(c(1, NA)) ## [1] NA O NULL é um valor especial para o R, isto é, ao contrário do NA, ele não tem um significado prático para a análise de dados, mas sim computacional. Ele representa a ausência de um vetor e é útil na construção da lógica de programação de alguns códigos. mtcars$coluna_que_nao_existe ## NULL O Inf representa um número muito grande (que o computador não consegue representar) ou um limite matemático. 2^2000 ## [1] Inf 2. Escreva um código que conte o número de NAs do vetor b. b &lt;- c(1, 0, NA, NA, NA, NA, 7, NA, NA, NA, NA, NA, 2, NA, NA, 10, 1, 1, NA) sum(is.na(b)) ## [1] 12 Data frames 1. Quais códigos abaixo retornam um vetor com a coluna mpg do data frame mtcars? a. mtcars$mpg mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 Retorna! b. mtcars[ , 3] mtcars[ , 3] ## [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 275.8 ## [13] 275.8 275.8 472.0 460.0 440.0 78.7 75.7 71.1 120.1 318.0 304.0 350.0 ## [25] 400.0 79.0 120.3 95.1 351.0 145.0 301.0 121.0 Não retorna. A coluna mpg é a primeira coluna do data frame. A coluna que esse código retornou foi a disp. c. mtcars(\"mpg\") mtcars(&quot;mpg&quot;) ## Error in mtcars(&quot;mpg&quot;): could not find function &quot;mtcars&quot; A sintaxe desse código não é válida pois () não são utilizados para fazer subsetting, mas sim para definir os argumentos de uma função (e mtcars não é uma função). d. mtcars[ , \"mpg\"] mtcars[ , &quot;mpg&quot;] ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 “Retorna!” e. mtcars.mpg mtcars.mpg ## Error in eval(expr, envir, enclos): object &#39;mtcars.mpg&#39; not found Essa sintaxe não é válida no R. Ele está procurando por um objeto chamado mtcars.mpg, que não existe. f. mtcars[ , 1] mtcars[ , 1] ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 Retorna! g. mtcars[1, 1] mtcars[1, 1] ## [1] 21 Esse código retorna apenas o primeiro valor da coluna mpg. mpg$mtcars mpg$mtcars ## Error in eval(expr, envir, enclos): object &#39;mpg&#39; not found Não retorna. Essa sintaxe não é válida para selecionar colunas de um data frame. O correto seria nome_do_data_frame$nome_da_coluna. 2. Para que serve a função str(). Dê um exemplo do seu uso. Serve para espiarmos a estrutura de um data frame, como número de linhas, colunas, classes das colunas e exemplo de valores em cada uma delas. str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... 3. Para que serve a função nanes(). Dê um exemplo do seu uso. Serve para observamos os nomes das colunas de um data frame. O valor retornado é um vetor de strings. names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; 4. Use o data frame airquality para responder às questões abaixo: a. Quantas colunas airquality tem? ncol(airquality) ## [1] 6 b. Quantas linhas airquality tem? nrow(airquality) ## [1] 153 c. O que a função head() retorna? Retorna as 6 primeiras linhas do data frame. head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 d. Quais são os nomes das colunas? names(airquality) ## [1] &quot;Ozone&quot; &quot;Solar.R&quot; &quot;Wind&quot; &quot;Temp&quot; &quot;Month&quot; &quot;Day&quot; e. Qual é a classe da coluna Ozone? str(airquality) ## &#39;data.frame&#39;: 153 obs. of 6 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... # Também podemos ver apenas a coluna Ozone class(airquality$Ozone) ## [1] &quot;integer&quot; 5. Desafio. Calculando desvio-padrão no R. Use o data frame airquality para responder às questões abaixo: a. Tire a média da coluna Ozone e guarde em um objeto. media_ozone &lt;- mean(airquality$Ozone, na.rm = TRUE) b. Guarde em um objeto o vetor correspondente à coluna Ozone subtraída da sua própria média (calculada em no item a). ozone_centralizado &lt;- airquality$Ozone - media_ozone c. Eleve o vetor calculado em (b) ao quadrado. Salve o resultado em um novo objeto. ozone_centr_quadrado &lt;- ozone_centralizado ^ 2 d. Tire a média do vetor calculado em (c) e salve o resultado em um objeto chamado variancia. Em seguida, calcule a raiz quadrada desse valor e salve em um objeto chamado desvio_padrao. variancia &lt;- mean(ozone_centr_quadrado, na.rm = TRUE) desvio_padrao &lt;- sqrt(variancia) e. Compare o valor de desvio_padrao com sd(airquality$Ozone) e pesquise por que os valores não são iguais. Dica: veja a documentação da função sd(). desvio_padrao ## [1] 32.84539 sd(airquality$Ozone, na.rm = TRUE) ## [1] 32.98788 Os valores não são iguais, pois na nossa conta, ao calcularmos a média no item (d), dividimos a soma de quadrados por n (tamanho da amostra, no caso, 116), enquanto na função sd() a divisão é por n - 1 (115). A divisão por n - 1, na Estatística, representa o estimador não viesado para a variância/desvio-padrão de uma quantidade. Na prática, ambas podem ser utilizadas como medidas de variabilidade, mas em contextos inferenciais o valor dividido por n - 1 é preferível. Para chegarmos no mesmo resultado, poderíamos fazer: # Número de valores sem NA n &lt;- length(na.omit(airquality$Ozone)) variancia &lt;- sum(ozone_centr_quadrado, na.rm = TRUE) / (n - 1) desvio_padrao &lt;- sqrt(variancia) desvio_padrao ## [1] 32.98788 6. Use o data frame airquality para responder às questões abaixo. a. Conte quantos NAs tem na coluna Solar.R. sum(is.na(airquality$Solar.R)) ## [1] 7 b. Filtre a tabela airqualitycom apenas linhas em que Solar.R é NA. tab &lt;- airquality[is.na(airquality$Solar.R),] # Imprimindo apenas as primeiras linhas para facilitar a leitura head(tab) ## Ozone Solar.R Wind Temp Month Day ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 ## 11 7 NA 6.9 74 5 11 ## 27 NA NA 8.0 57 5 27 ## 96 78 NA 6.9 86 8 4 ## 97 35 NA 7.4 85 8 5 c. Filtre a tabela airquality com apenas linhas em que Solar.R não é NA. tab &lt;- airquality[!is.na(airquality$Solar.R),] # Imprimindo apenas as primeiras linhas para facilitar a leitura head(tab) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 7 23 299 8.6 65 5 7 ## 8 19 99 13.8 59 5 8 d. Filtre a tabela airquality com apenas linhas em que Solar.R não é NA e Month é igual a 5. tab &lt;- airquality[!is.na(airquality$Solar.R) &amp; airquality$Month &gt; 5,] # Imprimindo apenas as primeiras linhas para facilitar a leitura head(tab) ## Ozone Solar.R Wind Temp Month Day ## 32 NA 286 8.6 78 6 1 ## 33 NA 287 9.7 74 6 2 ## 34 NA 242 16.1 67 6 3 ## 35 NA 186 9.2 84 6 4 ## 36 NA 220 8.6 85 6 5 ## 37 NA 264 14.3 79 6 6 Mais sobre funções 1. Qual dos códigos abaixo devolverá um erro se for avaliado? a. 3 * 5 + 10 3 * 5 + 10 ## [1] 25 Sem erro. b. function &lt;- 10 function &lt;- 10 ## Error: &lt;text&gt;:1:10: unexpected assignment ## 1: function &lt;- ## ^ Retorna erro pois function é um nome reservado no R. Não podemos utilizá-lo para nomear outros objetos. c. mean(1, 10) mean(1, 10) ## [1] 1 Não retorna erro, mas o 10 não é considerado na média. O código correto seria mean(c(1, 10)). d. (soma &lt;- sum(1, 1)) (soma &lt;- sum(1, 1)) ## [1] 2 Não retorna erro. Cercar o código com parênteses força a saída a sempre ser apresentada no Console, além de ser gravada dentro do objeto. 2. Crie uma função que receba um número e retorne o quadrado deste número. quadrado &lt;- function(x) { x ^ 2 } quadrado(2) ## [1] 4 quadrado(3) ## [1] 9 quadrado(0) ## [1] 0 3. Crie uma função que receba 2 números e devolva a raiz quadrada da soma desses números. raiz_da_soma &lt;- function(a, b) { sqrt(a + b) } raiz_da_soma(2, 2) ## [1] 2 raiz_da_soma(1, 4) ## [1] 2.236068 4. Crie uma função que receba dois valores (numéricos) e devolva o maior deles. retornar_maior &lt;- function(x, y) { vetor &lt;- c(x, y) filtro &lt;- c(x &gt; y, x &lt;= y) vetor[filtro] } retornar_maior(10, 20) ## [1] 20 retornar_maior(5, -5) ## [1] 5 *Também poderíamos resolver usando a função max(). retornar_maior &lt;- function(x, y) { max(x, y) } retornar_maior(10, 20) ## [1] 20 retornar_maior(5, -5) ## [1] 5 5. Use a função runif() para criar uma função que retorne um número aleatório inteiro entre 0 e 10 (0 e 10 inclusive). Caso você não conheça a função runif(), rode help(runif) para ler a sua documentação. sortear_numero &lt;- function() { numero &lt;- runif(1, min = 0, max = 10) numero_inteiro &lt;- round(numero) return(numero_inteiro) } sortear_numero() ## [1] 4 6. Rode help(sample) para descobrir o que a função sample() faz. Em seguida: a. Use a função sample() para escrever uma função que devolva uma linha aleatória de um data frame. sortear_linha &lt;- function(data_frame) { num_linhas &lt;- nrow(data_frame) linha_sorteada &lt;- sample(1:num_linhas, 1) data_frame[linha_sorteada, ] } sortear_linha(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 b. Generalize a função para retornar um número qualquer de linhas, escolhido pelo usuário. sortear_linha &lt;- function(data_frame, n) { num_linhas &lt;- nrow(data_frame) linha_sorteada &lt;- sample(1:num_linhas, n) data_frame[linha_sorteada, ] } sortear_linha(mtcars, 10) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Controle de fluxo 1. Por que o código abaixo retorna erro? Arrume o código para retornar o valor TRUE. x &lt;- 4 if(x = 4) { TRUE } **Porque a expressão dentro do if deve retornar um valor lógico (TRUE ou FALSE) e o código x = 4 é uma atribuição (equivalente a x &lt;- 4). O correto seria utilizar == em vez de =.* x &lt;- 4 if(x == 4) { TRUE } ## [1] TRUE 2. Usando if e else, escreva um código que retorne a string \"número\" caso um valor x seja da classe numeric ou integer; a string \"palavra\" caso seja da classe character; e NA caso contrário. x &lt;- 10 if (class(x) == &quot;numeric&quot; | class(x) == &quot;integer&quot;) { &quot;número&quot; } else if (class(x) == &quot;character&quot;) { &quot;palavra&quot; } else { NA } ## [1] &quot;número&quot; Uma solução mais simples seria utilizar as funções is.numeric() e is.character(). x &lt;- &quot;qualquer texto&quot; if (is.numeric(x)) { &quot;número&quot; } else if (is.character(x)) { &quot;palavra&quot; } else { NA } ## [1] &quot;palavra&quot; 3. Usando apenas for e a função length(), construa uma função que calcule a média de um vetor numérico qualquer. Construa uma condição para a função retornar NULL caso o vetor não seja numérico. minha_media &lt;- function(vetor) { soma &lt;- 0 for (i in 1:length(vetor)) { soma &lt;- soma + vetor[i] } media &lt;- soma / length(vetor) return(media) } minha_media(c(1, 2)) ## [1] 1.5 minha_media(0:10) ## [1] 5 minha_media(c(2, 2)) ## [1] 2 4. Utilize o vetor a para resolver as questões a seguir: a &lt;- c(10, 3, 5, -1, 3, -4, 8, 9, -10) a. Utilize o for para imprimir as médias acumuladas do vetor a, isto é, primeiro vamos imprimir 10, depois a média entre 10 e 3, depois a média entre 10, 3 e 5 e assim por diante. soma &lt;- 0 for(i in 1:length(a)) { soma &lt;- soma + a[i] print(soma / i) } ## [1] 10 ## [1] 6.5 ## [1] 6 ## [1] 4.25 ## [1] 4 ## [1] 2.666667 ## [1] 3.428571 ## [1] 4.125 ## [1] 2.555556 b. Adapte o laço que você fez no item anterior para ignorar os valores negativos, isto é, em caso de valor negativo, o laço não deve calcular a média e não imprimir nada. soma &lt;- 0 divisor &lt;- 0 for(i in 1:length(a)) { if (a[i] &gt;= 0) { soma &lt;- soma + a[i] divisor &lt;- divisor + 1 print(soma / divisor) } } ## [1] 10 ## [1] 6.5 ## [1] 6 ## [1] 5.25 ## [1] 5.8 ## [1] 6.333333 "],["12-2-pipe-1.html", "12.2 Pipe", " 12.2 Pipe 1. Reescreva a expressão abaixo utilizando o %&gt;%. round(mean(sum(1:10)/3), digits = 1) 1:10 %&gt;% sum %&gt;% divide_by(3) %&gt;% round(digits = 1) 2. Reescreva o código abaixo utilizando o %&gt;%. # Setamos a semente que gera números aleatórios para deixar o resultado reprodutível set.seed(137) x &lt;- rnorm(100) x.pos &lt;- x[x&gt;0] media &lt;- mean(x.pos) saida &lt;- round(media, 2) saida set.seed(137) rnorm(100) %&gt;% magrittr::extract(. &gt; 0) %&gt;% mean %&gt;% round(digits = 2) 3. Sem rodar, diga qual a saída do código abaixo. Consulte o help das funções caso precise. 2 %&gt;% add(2) %&gt;% c(6, NA) %&gt;% mean(na.rm = T) %&gt;% equals(5) Primeiro, somamos 2 com 2, gerando o valor 4. Então colocamos esse valor em um vetor com os valores 6 e NA. Em seguida, tiramos a média desse vetor, desconsiderando o NA, obtendo o valor 5. Por fim, testemos se o valor é igual a 5, obtendo o valor TRUE. "],["12-3-o-pacote-dplyr.html", "12.3 O pacote dplyr", " 12.3 O pacote dplyr 12.3.1 Selecionando colunas Utilize a base imdb nos exercícios a seguir. 1. Teste aplicar a função glimpse() do pacote {dplyr} à base imdb. O que ela faz? glimpse(imdb) ## Rows: 3,807 ## Columns: 15 ## $ titulo &lt;chr&gt; &quot;Avatar &quot;, &quot;Pirates of the Caribbean: At World&#39;s End &quot;… ## $ ano &lt;dbl&gt; 2009, 2007, 2012, 2012, 2007, 2010, 2015, 2016, 2006, … ## $ diretor &lt;chr&gt; &quot;James Cameron&quot;, &quot;Gore Verbinski&quot;, &quot;Christopher Nolan&quot;… ## $ duracao &lt;dbl&gt; 178, 169, 164, 132, 156, 100, 141, 183, 169, 151, 150,… ## $ cor &lt;chr&gt; &quot;Color&quot;, &quot;Color&quot;, &quot;Color&quot;, &quot;Color&quot;, &quot;Color&quot;, &quot;Color&quot;, … ## $ generos &lt;chr&gt; &quot;Action|Adventure|Fantasy|Sci-Fi&quot;, &quot;Action|Adventure|F… ## $ pais &lt;chr&gt; &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;, &quot;USA&quot;… ## $ classificacao &lt;chr&gt; &quot;A partir de 13 anos&quot;, &quot;A partir de 13 anos&quot;, &quot;A parti… ## $ orcamento &lt;dbl&gt; 237000000, 300000000, 250000000, 263700000, 258000000,… ## $ receita &lt;dbl&gt; 760505847, 309404152, 448130642, 73058679, 336530303, … ## $ nota_imdb &lt;dbl&gt; 7.9, 7.1, 8.5, 6.6, 6.2, 7.8, 7.5, 6.9, 6.1, 7.3, 6.5,… ## $ likes_facebook &lt;dbl&gt; 33000, 0, 164000, 24000, 0, 29000, 118000, 197000, 0, … ## $ ator_1 &lt;chr&gt; &quot;CCH Pounder&quot;, &quot;Johnny Depp&quot;, &quot;Tom Hardy&quot;, &quot;Daryl Saba… ## $ ator_2 &lt;chr&gt; &quot;Joel David Moore&quot;, &quot;Orlando Bloom&quot;, &quot;Christian Bale&quot;,… ## $ ator_3 &lt;chr&gt; &quot;Wes Studi&quot;, &quot;Jack Davenport&quot;, &quot;Joseph Gordon-Levitt&quot;,… A função glimpse() traz um resumo da base, contendo o número de linhas, colunas, o nome e tipo das colunas e as primeiras observações de cada coluna. 2. Crie uma tabela com apenas as colunas titulo, diretor, e orcamento. Salve em um objeto chamado imdb_simples. imdb_simples &lt;- select(imdb, titulo, diretor, orcamento) imdb_simples ## # A tibble: 3,807 x 3 ## titulo diretor orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Avatar James Cameron 237000000 ## 2 Pirates of the Caribbean: At World&#39;s End Gore Verbinski 300000000 ## 3 The Dark Knight Rises Christopher Nolan 250000000 ## 4 John Carter Andrew Stanton 263700000 ## 5 Spider-Man 3 Sam Raimi 258000000 ## 6 Tangled Nathan Greno 260000000 ## 7 Avengers: Age of Ultron Joss Whedon 250000000 ## 8 Batman v Superman: Dawn of Justice Zack Snyder 250000000 ## 9 Superman Returns Bryan Singer 209000000 ## 10 Pirates of the Caribbean: Dead Man&#39;s Chest Gore Verbinski 225000000 ## # … with 3,797 more rows 3. Selecione apenas as colunas ator_1, ator_2 e ator_3 usando o ajudante contains(). select(imdb, contains(&quot;ator&quot;)) ## # A tibble: 3,807 x 3 ## ator_1 ator_2 ator_3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CCH Pounder Joel David Moore Wes Studi ## 2 Johnny Depp Orlando Bloom Jack Davenport ## 3 Tom Hardy Christian Bale Joseph Gordon-Levitt ## 4 Daryl Sabara Samantha Morton Polly Walker ## 5 J.K. Simmons James Franco Kirsten Dunst ## 6 Brad Garrett Donna Murphy M.C. Gainey ## 7 Chris Hemsworth Robert Downey Jr. Scarlett Johansson ## 8 Henry Cavill Lauren Cohan Alan D. Purwin ## 9 Kevin Spacey Marlon Brando Frank Langella ## 10 Johnny Depp Orlando Bloom Jack Davenport ## # … with 3,797 more rows 4. Usando a função select() (e seus ajudantes), escreva códigos que retornem a base IMDB sem as colunas ator_1, ator_2 e ator_3. Escreva todas as soluções diferentes que você conseguir pensar. select(imdb, -starts_with(&quot;ator&quot;)) select(imdb, -ator_1, -ator_2, -ator_3) select(imdb, -(ator_1:ator_3)) select(imdb, titulo:likes_facebook) select(imdb, -contains(&quot;ator&quot;)) 12.3.2 Ordenando a base 1. Ordene os filmes em ordem crescente de ano e decrescente de receita e salve em um objeto chamado filmes_ordenados. filmes_ordenados &lt;- arrange(imdb, ano, desc(receita)) 2. Selecione apenas as colunas titulo e orcamento e então ordene de forma decrescente pelo orcamento. # Aninhando as funções arrange(select(imdb, titulo, orcamento), desc(orcamento)) # Criando objeto intermediário imdb_aux &lt;- select(imdb, titulo, orcamento) arrange(imdb_aux, desc(orcamento)) # Pipe s2 imdb %&gt;% select(titulo, orcamento) %&gt;% arrange(desc(orcamento)) 12.3.3 Filtrando linhas Utilize a base imdb nos exercícios a seguir. 1. Crie um objeto chamado filmes_pb apenas com filmes preto e branco. # Vendo categorias da variável cor unique(imdb$cor) ## [1] &quot;Color&quot; &quot;Black and White&quot; NA # Filtrando imdb %&gt;% filter(cor == &quot;Black and White&quot;) ## # A tibble: 149 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Pearl… 2001 Michae… 184 Blac… Action… USA A partir de … 140000000 ## 2 The A… 2004 Martin… 170 Blac… Biogra… USA A partir de … 110000000 ## 3 Ali 2001 Michae… 165 Blac… Biogra… USA A partir de … 107000000 ## 4 Erago… 2006 Stefen… 104 Blac… Action… USA Livre 100000000 ## 5 Seabi… 2003 Gary R… 140 Blac… Drama|… USA A partir de … 87000000 ## 6 Bewit… NA &lt;NA&gt; 25 Blac… Comedy… USA Outros NA ## 7 Nine 2009 Rob Ma… 118 Blac… Drama|… USA A partir de … 80000000 ## 8 The L… 2003 Stephe… 110 Blac… Action… USA A partir de … 78000000 ## 9 War H… 2011 Steven… 146 Blac… Drama|… USA A partir de … 66000000 ## 10 Space… 2000 Clint … 130 Blac… Action… USA A partir de … 65000000 ## # … with 139 more rows, and 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; 2. Crie um objeto chamado curtos_legais com filmes de 90 minutos ou menos de duração e nota no imdb maior do que 8.5. curtos_legais &lt;- imdb %&gt;% filter(duracao &lt;= 90, nota_imdb &gt; 8.5) 3. Retorne tabelas (tibbles) apenas com: a. filmes coloridos anteriores a 1950; imdb %&gt;% filter(cor == &quot;Color&quot;, ano &lt; 1950) ## # A tibble: 14 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Pinoc… 1940 Norman… 88 Color Animat… USA Outros 2600000 ## 2 Duel … 1946 King V… 144 Color Drama|… USA Outros 8000000 ## 3 Tycoo… 1947 Richar… 95 Color Advent… USA Outros 3209000 ## 4 State… 1945 Walter… 100 Color Musica… USA Outros NA ## 5 Gone … 1939 Victor… 226 Color Drama|… USA Outros 3977000 ## 6 The P… 1948 Vincen… 102 Color Advent… USA Outros 3700000 ## 7 It&#39;s … 1946 Frank … 118 Color Drama|… USA Livre 3180000 ## 8 Bathi… 1944 George… 101 Color Comedy… USA Outros 2361000 ## 9 Fanta… 1940 James … 120 Color Animat… USA Outros 2280000 ## 10 She W… 1949 John F… 103 Color Western USA Outros 1600000 ## 11 Spell… 1945 Alfred… 95 Color Film-N… USA Outros 1696377 ## 12 Snow … 1937 Willia… 83 Color Animat… USA Outros 2000000 ## 13 Casab… 1942 Michae… 82 Color Drama|… USA Livre 950000 ## 14 Bambi 1942 James … 70 Color Animat… USA Outros NA ## # … with 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; b. filmes do “Woody Allen” ou do “Wes Anderson”; imdb %&gt;% filter(diretor == &quot;Woody Allen&quot; | diretor == &quot;Wes Anderson&quot;) ## # A tibble: 25 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 The L… 2004 Wes An… 119 Color Advent… USA A partir de … 50000000 ## 2 Fanta… 2009 Wes An… 87 Color Advent… USA Livre 40000000 ## 3 The G… 2014 Wes An… 99 Color Advent… USA A partir de … 25000000 ## 4 The R… 2001 Wes An… 110 Color Comedy… USA A partir de … 21000000 ## 5 The C… 2001 Woody … 103 Color Comedy… USA A partir de … 26000000 ## 6 To Ro… 2012 Woody … 112 Color Comedy… USA A partir de … 17000000 ## 7 Bulle… 1994 Woody … 98 Color Comedy… USA A partir de … 20000000 ## 8 Decon… 1997 Woody … 96 Color Comedy USA A partir de … 20000000 ## 9 Every… 1996 Woody … 101 Color Comedy… USA A partir de … 20000000 ## 10 Blue … 2013 Woody … 98 Color Drama USA A partir de … 18000000 ## # … with 15 more rows, and 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; c. filmes do “Steven Spielberg” ordenados de forma decrescente por ano, mostrando apenas as colunas titulo e ano; imdb %&gt;% filter(diretor == &quot;Steven Spielberg&quot;) %&gt;% arrange(desc(ano)) %&gt;% select(titulo, ano) ## # A tibble: 24 x 2 ## titulo ano ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bridge of Spies 2015 ## 2 Lincoln 2012 ## 3 The Adventures of Tintin 2011 ## 4 War Horse 2011 ## 5 Indiana Jones and the Kingdom of the Crystal Skull 2008 ## 6 War of the Worlds 2005 ## 7 The Terminal 2004 ## 8 Minority Report 2002 ## 9 Catch Me If You Can 2002 ## 10 A.I. Artificial Intelligence 2001 ## # … with 14 more rows d. filmes que tenham “Action” ou “Comedy” entre os seus gêneros; library(stringr) # Solução 1 imdb %&gt;% filter(str_detect(generos, &quot;Action&quot;) | str_detect(generos, &quot;Comedy&quot;)) ## # A tibble: 2,187 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 2,177 more rows, and 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; e. filmes que tenham “Action” e “Comedy” entre os seus gêneros e tenha nota_imdb maior que 8; imdb %&gt;% filter(str_detect(generos, &quot;Action&quot;), str_detect(generos, &quot;Comedy&quot;)) ## # A tibble: 203 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Men i… 2012 Barry … 106 Color Action… USA A partir de … 225000000 ## 2 Rush … 2007 Brett … 91 Color Action… USA A partir de … 140000000 ## 3 Monst… 2009 Rob Le… 94 Color Action… USA Livre 175000000 ## 4 Wild … 1999 Barry … 106 Color Action… USA A partir de … 170000000 ## 5 Suici… 2016 David … 123 Color Action… USA A partir de … 175000000 ## 6 Big H… 2014 Don Ha… 102 Color Action… USA Livre 165000000 ## 7 Madag… 2008 Eric D… 89 Color Action… USA Livre 150000000 ## 8 G-For… 2009 Hoyt Y… 88 Color Action… USA Livre 150000000 ## 9 Kung … 2011 Jennif… 90 Color Action… USA Livre 150000000 ## 10 Mars … 2011 Simon … 88 Color Action… USA Livre 150000000 ## # … with 193 more rows, and 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; f. filmes que não possuem informação tanto de receita quanto de orçamento (isto é, possuem NA em ambas as colunas). imdb %&gt;% filter(is.na(orcamento), is.na(receita)) ## # A tibble: 137 x 15 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 The A… NA &lt;NA&gt; 60 Color Action… USA Outros NA ## 2 Ben-H… 2016 Timur … 141 Color Advent… USA A partir de … NA ## 3 Hanni… NA &lt;NA&gt; 44 Color Crime|… USA Outros NA ## 4 All T… 1979 Bob Fo… 123 Color Comedy… USA A partir de … NA ## 5 Dared… NA &lt;NA&gt; 54 &lt;NA&gt; Action… USA Outros NA ## 6 Bewit… NA &lt;NA&gt; 25 Blac… Comedy… USA Outros NA ## 7 Const… NA &lt;NA&gt; 43 Color Drama|… USA Outros NA ## 8 Life NA &lt;NA&gt; 45 Color Crime|… USA Outros NA ## 9 Sleep… NA &lt;NA&gt; 45 Color Advent… USA Outros NA ## 10 Last … NA &lt;NA&gt; 30 Color Comedy USA Outros NA ## # … with 127 more rows, and 6 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; 12.3.4 Modificando e criando novas colunas 1. Crie uma coluna chamada prejuizo (orcamento - receita) e salve a nova tabela em um objeto chamado imdb_prejuizo. Em seguida, filtre apenas os filmes que deram prejuízo e ordene a tabela por ordem crescente de prejuízo. imdb_prejuizo &lt;- imdb %&gt;% mutate(prejuizo = orcamento - receita) imdb_prejuizo %&gt;% filter(prejuizo &gt; 0) %&gt;% arrange(prejuizo) ## # A tibble: 1,312 x 16 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 The H… 2009 Michel… 93 Color Docume… USA Outros 160000 ## 2 Newly… 2011 Edward… 95 Color Comedy… USA Outros 9000 ## 3 Short… 2006 John C… 101 Color Comedy… USA Outros 2000000 ## 4 Slam 1998 Marc L… 100 Color Drama USA A partir de … 1000000 ## 5 Pink … 1971 James … 65 Color Drama|… USA Outros 27000 ## 6 The F… 2011 Brando… 82 Color Comedy USA A partir de … 60000 ## 7 Assau… 2005 Jean-F… 109 Color Action… USA A partir de … 20000000 ## 8 The B… 2002 Sherma… 103 Color Drama|… USA Outros 200000 ## 9 Latte… 2003 C. Jay… 107 Color Comedy… USA A partir de … 850000 ## 10 Happy… 2014 Joe Sw… 82 Color Comedy… USA A partir de … 70000 ## # … with 1,302 more rows, and 7 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;, ## # prejuizo &lt;dbl&gt; 2. Fazendo apenas uma chamada da função mutate(), crie as seguintes colunas novas na base imdb: a. lucro = receita - orcamento b. lucro_medio c. lucro_relativo = (lucro - lucro_medio)/lucro_medio d. houve_lucro = ifelse(lucro &gt; 0, \"sim\", \"não\") imdb %&gt;% mutate( lucro = receita - orcamento, lucro_medio = mean(lucro, na.rm = TRUE), lucro_relativo = (lucro - lucro_medio) / lucro_medio, houve_lucro = ifelse(lucro &gt; 0, &quot;sim&quot;, &quot;não&quot;) ) ## # A tibble: 3,807 x 19 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 10 more variables: receita &lt;dbl&gt;, ## # nota_imdb &lt;dbl&gt;, likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ## # ator_3 &lt;chr&gt;, lucro &lt;dbl&gt;, lucro_medio &lt;dbl&gt;, lucro_relativo &lt;dbl&gt;, ## # houve_lucro &lt;chr&gt; 3. Crie uma nova coluna que classifique o filme em \"recente\" (posterior a 2000) e \"antigo\" (de 2000 para trás). imdb %&gt;% mutate(antigo_ou_recente = ifelse(ano &gt; 2000, &quot;recente&quot;, &quot;antigo&quot;)) ## # A tibble: 3,807 x 16 ## titulo ano diretor duracao cor generos pais classificacao orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Avata… 2009 James … 178 Color Action… USA A partir de … 237000000 ## 2 Pirat… 2007 Gore V… 169 Color Action… USA A partir de … 300000000 ## 3 The D… 2012 Christ… 164 Color Action… USA A partir de … 250000000 ## 4 John … 2012 Andrew… 132 Color Action… USA A partir de … 263700000 ## 5 Spide… 2007 Sam Ra… 156 Color Action… USA A partir de … 258000000 ## 6 Tangl… 2010 Nathan… 100 Color Advent… USA Livre 260000000 ## 7 Aveng… 2015 Joss W… 141 Color Action… USA A partir de … 250000000 ## 8 Batma… 2016 Zack S… 183 Color Action… USA A partir de … 250000000 ## 9 Super… 2006 Bryan … 169 Color Action… USA A partir de … 209000000 ## 10 Pirat… 2006 Gore V… 151 Color Action… USA A partir de … 225000000 ## # … with 3,797 more rows, and 7 more variables: receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # likes_facebook &lt;dbl&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;, ## # antigo_ou_recente &lt;chr&gt; 12.3.5 Summarisando a base Utilize a base imdb nos exercícios a seguir. 1. Calcule a duração média e mediana dos filmes da base. imdb %&gt;% summarise( duracao_media = mean(duracao, na.rm = TRUE), duracao_mediana = median(duracao, na.rm = TRUE) ) ## # A tibble: 1 x 2 ## duracao_media duracao_mediana ## &lt;dbl&gt; &lt;dbl&gt; ## 1 106. 103 2. Calcule o lucro médio dos filmes com duração menor que 60 minutos. imdb %&gt;% filter(duracao &lt; 60) %&gt;% mutate(lucro = receita - orcamento) %&gt;% summarise(lucro_medio = mean(lucro, na.rm = TRUE)) ## # A tibble: 1 x 1 ## lucro_medio ## &lt;dbl&gt; ## 1 632454. 3. Apresente na mesma tabela o lucro médio dos filmes com duracao menor que 60 minutos e o lucro médio dos filmes com duracao maior ou igual a 60 minutos. imdb %&gt;% mutate( lucro = receita - orcamento, duracao_cat = ifelse(duracao &lt; 60, &quot;menor 60 min&quot;, &quot;60 ou mais min&quot;) ) %&gt;% filter(!is.na(lucro)) %&gt;% group_by(duracao_cat) %&gt;% summarise( lucro_medio = mean(lucro, na.rm = TRUE) ) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 2 ## duracao_cat lucro_medio ## &lt;chr&gt; &lt;dbl&gt; ## 1 60 ou mais min 17274472. ## 2 menor 60 min 632454. 4. Retorne tabelas (tibbles) apenas com: a. a nota IMDB média dos filmes por tipo de classificacao; imdb %&gt;% group_by(classificacao) %&gt;% summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 4 x 2 ## classificacao nota_media ## &lt;chr&gt; &lt;dbl&gt; ## 1 A partir de 13 anos 6.18 ## 2 A partir de 18 anos 6.47 ## 3 Livre 6.26 ## 4 Outros 6.65 b. a receita média e mediana dos filmes por ano; imdb %&gt;% group_by(ano) %&gt;% summarise( receita_media = mean(receita, na.rm = TRUE), receita_mediana = median(receita, na.rm = TRUE) ) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 91 x 3 ## ano receita_media receita_mediana ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1916 NaN NA ## 2 1920 3000000 3000000 ## 3 1925 NaN NA ## 4 1929 2808000 2808000 ## 5 1930 NaN NA ## 6 1932 NaN NA ## 7 1933 2300000 2300000 ## 8 1934 NaN NA ## 9 1935 3000000 3000000 ## 10 1936 163245 163245 ## # … with 81 more rows c. apenas o nome dos diretores com mais de 10 filmes. imdb %&gt;% filter(!is.na(diretor)) %&gt;% group_by(diretor) %&gt;% summarise(num_filmes = n()) %&gt;% filter(num_filmes &gt; 10) %&gt;% select(diretor) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 22 x 1 ## diretor ## &lt;chr&gt; ## 1 Barry Levinson ## 2 Clint Eastwood ## 3 Francis Ford Coppola ## 4 John Carpenter ## 5 Kevin Smith ## 6 Martin Scorsese ## 7 Michael Bay ## 8 Renny Harlin ## 9 Ridley Scott ## 10 Rob Cohen ## # … with 12 more rows Também podemos usar a função count(). imdb %&gt;% filter(!is.na(diretor)) %&gt;% count(diretor, name = &quot;num_filmes&quot;) %&gt;% filter(num_filmes &gt; 10) %&gt;% select(diretor) ## # A tibble: 22 x 1 ## diretor ## &lt;chr&gt; ## 1 Barry Levinson ## 2 Clint Eastwood ## 3 Francis Ford Coppola ## 4 John Carpenter ## 5 Kevin Smith ## 6 Martin Scorsese ## 7 Michael Bay ## 8 Renny Harlin ## 9 Ridley Scott ## 10 Rob Cohen ## # … with 12 more rows 12.3.6 Juntando duas bases 1. Utilize a base imdb para resolver os itens a seguir. a. Salve em um novo objeto uma tabela com a nota média dos filmes de cada diretor. Essa tabela deve conter duas colunas (diretor e nota_imdb_media) e cada linha deve ser um diretor diferente. nota_diretores &lt;- imdb %&gt;% group_by(diretor) %&gt;% summarise(nota_imdb_media = mean(nota_imdb)) ## `summarise()` ungrouping output (override with `.groups` argument) nota_diretores ## # A tibble: 1,813 x 2 ## diretor nota_imdb_media ## &lt;chr&gt; &lt;dbl&gt; ## 1 A. Raven Cruz 1.9 ## 2 Aaron Hann 6 ## 3 Aaron Schneider 7.1 ## 4 Aaron Seltzer 2.7 ## 5 Abel Ferrara 6.6 ## 6 Adam Carolla 6.1 ## 7 Adam Goldberg 5.4 ## 8 Adam Green 5.7 ## 9 Adam Jay Epstein 3.8 ## 10 Adam Marcus 4.3 ## # … with 1,803 more rows b. Use o left_join() para trazer a coluna nota_imdb_media da tabela do item anterior para a tabela imdb original. imdb %&gt;% left_join(nota_diretores, by = &quot;diretor&quot;) %&gt;% select(nota_imdb_media, everything()) ## # A tibble: 3,807 x 16 ## nota_imdb_media titulo ano diretor duracao cor generos pais ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 7.88 Avata… 2009 James … 178 Color Action… USA ## 2 6.99 Pirat… 2007 Gore V… 169 Color Action… USA ## 3 8.43 The D… 2012 Christ… 164 Color Action… USA ## 4 7.73 John … 2012 Andrew… 132 Color Action… USA ## 5 6.9 Spide… 2007 Sam Ra… 156 Color Action… USA ## 6 7.8 Tangl… 2010 Nathan… 100 Color Advent… USA ## 7 7.92 Aveng… 2015 Joss W… 141 Color Action… USA ## 8 7.18 Batma… 2016 Zack S… 183 Color Action… USA ## 9 7.26 Super… 2006 Bryan … 169 Color Action… USA ## 10 6.99 Pirat… 2006 Gore V… 151 Color Action… USA ## # … with 3,797 more rows, and 8 more variables: classificacao &lt;chr&gt;, ## # orcamento &lt;dbl&gt;, receita &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, likes_facebook &lt;dbl&gt;, ## # ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt; "],["referências.html", "Referências", " Referências Abaixo, listamos todas as referências utilizadas na construção deste livro. Allison Horst As ilustrações contidas nesse livro são da Allison Horst. Acompanhe o trabalho dela: https://github.com/allisonhorst Repositório com as ilustrações: https://github.com/allisonhorst/stats-illustrations Siga a Allison no Twitter: https://twitter.com/allison_horst Programação em R R for Data Sciente, do Garrett Grolemund e Hadley Wickham Advanced R, do Hadley Wickham R packages, do Hadley Wickham "]]
